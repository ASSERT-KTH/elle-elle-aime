#!/usr/bin/env python
# -*- encoding: utf-8 -*-


'''
@Author  :   Sen Fang
@Email   :   senf@kth.se
@Ide     :   vscode & conda
@File    :   run_chatgpt.py
@Time    :   2023/04/01 11:52:36
'''

"""This code is derived from ask_defects4j.py and can request ChatGPT or its improved version for program repair."""

import argparse
import time
import os
import json
from core.chatgpt.config.defs4j_config import AttrDict
from core.chatgpt.config.prompt_config import PROMPT
from core.chatgpt.request_chatgpt import ask_chatgpt
from core.chatgpt.verify_chatgpt_defects4j import verify_single_sample


def delete_dir(dir_path):
    """Delete a directory."""
    if os.path.exists(dir_path):
        os.system("rm -rf " + dir_path)


def ask_chatgpt_for_single_bug(args, defects4j_config, fixa_config):
    """Ask ChatGPT for a single bug."""
    # fix a single bug
    # checkout whether bug_id is string
    if isinstance(args.bug_id, int):
        args.bug_id = str(args.bug_id)
    buggy_dir = os.path.join(args.working_directory, "%s_%s_%s" %
                           (args.benchmark, args.project, args.bug_id)) + "_buggy"
    fixed_dir = os.path.join(args.working_directory, "%s_%s_%s" %
                           (args.benchmark, args.project, args.bug_id)) + "_fixed"

    if args.only_request:
        ask_chatgpt(args, defects4j_config, fixa_config)
    elif args.only_verify:
        # load all the patches generated by chatgpt from test folder
        dir_path = os.path.join(args.working_directory, args.benchmark, args.project, args.bug_id)
        with open(os.path.join(dir_path, "defects4j_config.json"), "r") as f:
            defects4j_config = json.load(f)
        response_dict = defects4j_config["respond_code_chunk"]
        for res_id in range(1, args.num_requests+1):
            defects4j_config["respond_code_chunk"] = response_dict[str(res_id)]
            try:
                print(f"Verify chatgpt reponse with id: {res_id}...")
                verify_single_sample(args, defects4j_config, res_id)
            except Exception as e:
                print("Error when verifying chatgpt response with id: ", args.bug_id, e)
                time.sleep(3)
        
        defects4j_config["respond_code_chunk"] = response_dict
        # Rewrite the defects4j_config.json file
        with open(os.path.join(dir_path, "defects4j_config.json"), "w") as f:
            json.dump(defects4j_config, f, indent=4)
        delete_dir(buggy_dir)
        delete_dir(fixed_dir)
    else:
        defects4j_config = ask_chatgpt(args, defects4j_config, fixa_config)
        try:
            if defects4j_config.respond_type == "UNRESPONDED":
                defects4j_config.respond_type = None
                delete_dir(buggy_dir)
                delete_dir(fixed_dir)
                return
            elif defects4j_config.respond_type == None:
                return
        except Exception as e:
            print("Error when asking chatgpt response with id: ", args.bug_id, e)
            time.sleep(3)
        # verify the patch
        dir_path = os.path.join(args.working_directory, args.benchmark, args.project, args.bug_id)
        response_dict = defects4j_config["respond_code_chunk"]
        for res_id in range(1, args.num_requests+1):
            defects4j_config["respond_code_chunk"] = response_dict[str(res_id)]
            try:
                print(f"Verify chatgpt reponse with id: {res_id}...")
                verify_single_sample(args, defects4j_config, res_id)
            except Exception as e:
                print("Error when verifying chatgpt response with id: ", args.bug_id, e)
        defects4j_config["respond_code_chunk"] = response_dict
        # Rewrite the defects4j_config.json file
        with open(os.path.join(dir_path, "defects4j_config.json"), "w") as f:
            json.dump(defects4j_config, f, indent=4)
        delete_dir(buggy_dir)
        delete_dir(fixed_dir)
        defects4j_config.respond_type = None


def main():
    parser = argparse.ArgumentParser(
        prog="ask", description='Checkout and fix the bug by chatable large language model')
    parser.add_argument("--model", "-m", required=True, choices=["gpt-3.5-turbo", "gpt-4", "gpt-4-32k"],
                        help="The chatable LLMs you want to use.")
    parser.add_argument("--only_request", "-or", type=bool, default=False, help="Only request the chatget to generate patch.")
    parser.add_argument("--only_verify", "-ov", type=bool, default=False, help="Only verify the patch generated by chatget.")
    parser.add_argument("--benchmark", "-b", required=True, default="Defects4J",
                        help="The benchmark to repair.")
    parser.add_argument("--project", "-p", required=False,
                        help="The project name (case sensitive).")
    parser.add_argument("--bug_id", "-bi", required=False, help="The bug id")
    parser.add_argument("--start", "-s", required=False,
                        help="The bug id starts from")
    parser.add_argument("--working_directory", "-w",
                        required=True, help="The working directory")
    parser.add_argument("--num_samples", "-ns", type=int, default=10, help="The number of samples to generate.")
    parser.add_argument("--num_requests", "-nr", type=int, default=10, help="The number of requests to generate.")
    parser.add_argument("--temperature", "-t", type=float, default=0.8, help="The temperature used to generate the patch.")
    parser.add_argument("--max_tokens", "-mt", type=int, default=3000, help="The max tokens used to generate the patch.")
    parser.add_argument("--top_p", "-tp", type=float, default=1., help="The top_p used to generate the patch.")
    parser.add_argument("--presence_penalty", "-pp", type=float, default=0.0, help="The presence_penalty used to generate the patch.")
    parser.add_argument("--frequency_penalty", "-fp", type=float, default=0.0, help="The frequency_penalty used to generate the patch.")
    parser.add_argument("--prompt_level", "-pml", type=str, default="easy", choices=["easy", "advanced", "domain"], help="The prompt used to generate the patch.")
    parser.add_argument("--prompt", "-pm", type=str, default=None, help="The prompt used to generate the patch.")
    parser.add_argument("--pl", "-pl", type=str, default="java", help="The programming language want to fix.")

    args = parser.parse_args()
    defects4j_config = AttrDict()
    fixa_config = defects4j_config.fixa_config
    defects4j_projects = defects4j_config.defects4j_projects
    defects4j_bug_size = defects4j_config.defects4j_bug_size
    defects4j_config.benchmark = args.benchmark
    if args.project != None:
        defects4j_config.project = args.project
    if args.bug_id != None:
        defects4j_config.bug_id = args.bug_id
    defects4j_config.model = args.model
    args.working_directory = args.model + "_" + args.working_directory + "_" + args.prompt_level
    assert args.project in defects4j_projects or args.project == None, "The project name is not valid, please check!"
    
    if args.prompt == None:
        args.prompt = PROMPT[args.prompt_level].replace("{}", args.pl)
    
    fixa_config['sample'] = args.num_samples

    if args.project != None and args.bug_id != None:
        print("Fixing bug: ", args.project, args.bug_id, "...")
        ask_chatgpt_for_single_bug(args, defects4j_config, fixa_config)
    elif args.project != None and args.bug_id == None:
        # fix all bugs in a project
        print("Fixing all bugs in project: ", args.project, "...")
        bug_size = defects4j_bug_size[args.project]
        starts_from = int(args.start) if args.start != None else 1
        for bug_id in range(starts_from, bug_size + 1):
            defects4j_config.bug_id = bug_id
            args.bug_id = bug_id
            ask_chatgpt_for_single_bug(args, defects4j_config, fixa_config)
    else:
        # fix all bugs from all projects
        print("Fixing all bugs from all projects...")
        for project, bug_size in defects4j_bug_size.items():
            args.project = project
            defects4j_config.project = project
            for bug_id in range(1, bug_size + 1):
                args.bug_id = bug_id
                defects4j_config.bug_id = args.bug_id
                ask_chatgpt_for_single_bug(args, defects4j_config, fixa_config)


if __name__ == "__main__":
    main()
 