{
  "files": 3, 
  "nb_test": 284, 
  "nb_error": 3, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.flink.streaming.runtime.operators.windowing.WindowOperatorTest"
  ], 
  "patch": "diff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java\nindex 1e4e453a43..84ee0b93cb 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/EvictingWindowOperator.java\n@@ -82,15 +82,11 @@ public void processElement(StreamRecord<IN> element) throws Exception {\n \t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(),\n \t\t\t\telement.getTimestamp());\n \n-\t\tK key = (K) getStateBackend().getCurrentKey();\n+\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n-\t\t\tif (mergingWindows == null) {\n-\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n-\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n-\t\t\t}\n \n+\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n \n \t\t\tfor (W window : elementWindows) {\n \t\t\t\t// If there is a merge, it can only result in a window that contains our new\n@@ -107,6 +103,7 @@ public void processElement(StreamRecord<IN> element) throws Exception {\n \t\t\t\t\t\t\tpublic void merge(W mergeResult,\n \t\t\t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n \t\t\t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n+\t\t\t\t\t\t\t\tcontext.key = key;\n \t\t\t\t\t\t\t\tcontext.window = mergeResult;\n \n \t\t\t\t\t\t\t\t// store for later use\n@@ -141,7 +138,7 @@ public void merge(W mergeResult,\n \t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult,\n \t\t\t\t\t\tmergeTriggerResult.f0);\n \n-\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n+\t\t\t\tprocessTriggerResult(combinedTriggerResult, actualWindow);\n \t\t\t}\n \n \t\t} else {\n@@ -157,14 +154,14 @@ public void merge(W mergeResult,\n \t\t\t\tcontext.window = window;\n \t\t\t\tTriggerResult triggerResult = context.onElement(element);\n \n-\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n+\t\t\t\tprocessTriggerResult(triggerResult, window);\n \t\t\t}\n \t\t}\n \t}\n \n \t@Override\n \t@SuppressWarnings(\"unchecked,rawtypes\")\n-\tprotected void processTriggerResult(TriggerResult triggerResult, K key, W window) throws Exception {\n+\tprotected void processTriggerResult(TriggerResult triggerResult, W window) throws Exception {\n \t\tif (!triggerResult.isFire() && !triggerResult.isPurge()) {\n \t\t\t// do nothing\n \t\t\treturn;\n@@ -175,7 +172,7 @@ protected void processTriggerResult(TriggerResult triggerResult, K key, W window\n \t\tMergingWindowSet<W> mergingWindows = null;\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tmergingWindows = mergingWindowsByKey.get(key);\n+\t\t\tmergingWindows = getMergingWindowSet();\n \t\t\tW stateWindow = mergingWindows.getStateWindow(window);\n \t\t\twindowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n \ndiff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java\nindex 7ef1af4700..49a2017549 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/MergingWindowSet.java\n@@ -17,6 +17,8 @@\n  */\n package org.apache.flink.streaming.runtime.operators.windowing;\n \n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.java.tuple.Tuple2;\n import org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner;\n import org.apache.flink.streaming.api.windowing.windows.Window;\n import org.slf4j.Logger;\n@@ -72,6 +74,24 @@ public MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner) {\n \t\twindows = new HashMap<>();\n \t}\n \n+\t/**\n+\t * Restores a {@link MergingWindowSet} from the given state.\n+\t */\n+\tpublic MergingWindowSet(MergingWindowAssigner<?, W> windowAssigner, ListState<Tuple2<W, W>> state) throws Exception {\n+\t\tthis.windowAssigner = windowAssigner;\n+\t\twindows = new HashMap<>();\n+\n+\t\tfor (Tuple2<W, W> window: state.get()) {\n+\t\t\twindows.put(window.f0, window.f1);\n+\t\t}\n+\t}\n+\n+\tpublic void persist(ListState<Tuple2<W, W>> state) throws Exception {\n+\t\tfor (Map.Entry<W, W> window: windows.entrySet()) {\n+\t\t\tstate.add(new Tuple2<>(window.getKey(), window.getValue()));\n+\t\t}\n+\t}\n+\n \t/**\n \t * Returns the state window for the given in-flight {@code Window}. The state window is the\n \t * {@code Window} in which we keep the actual state of a given in-flight window. Windows\ndiff --git a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\nindex c106e70c0f..919cee7465 100644\n--- a/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\n+++ b/flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/operators/windowing/WindowOperator.java\n@@ -22,6 +22,8 @@\n import org.apache.flink.annotation.Internal;\n import org.apache.flink.api.common.ExecutionConfig;\n import org.apache.flink.api.common.state.AppendingState;\n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n import org.apache.flink.api.common.state.MergingState;\n import org.apache.flink.api.common.state.State;\n import org.apache.flink.api.common.state.StateDescriptor;\n@@ -29,10 +31,13 @@\n import org.apache.flink.api.common.state.ValueStateDescriptor;\n import org.apache.flink.api.common.typeinfo.TypeInformation;\n import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.api.common.typeutils.base.VoidSerializer;\n import org.apache.flink.api.java.functions.KeySelector;\n import org.apache.flink.api.java.tuple.Tuple1;\n+import org.apache.flink.api.java.tuple.Tuple2;\n import org.apache.flink.api.java.typeutils.InputTypeConfigurable;\n import org.apache.flink.api.java.typeutils.TypeExtractor;\n+import org.apache.flink.api.java.typeutils.runtime.TupleSerializer;\n import org.apache.flink.core.memory.DataInputView;\n import org.apache.flink.runtime.state.AbstractStateBackend;\n import org.apache.flink.runtime.state.StateHandle;\n@@ -224,6 +229,25 @@ public final void open() throws Exception {\n \t@Override\n \tpublic final void close() throws Exception {\n \t\tsuper.close();\n+\t\ttimestampedCollector = null;\n+\t\twatermarkTimers = null;\n+\t\twatermarkTimersQueue = null;\n+\t\tprocessingTimeTimers = null;\n+\t\tprocessingTimeTimersQueue = null;\n+\t\tcontext = null;\n+\t\tmergingWindowsByKey = null;\n+\t}\n+\n+\t@Override\n+\tpublic void dispose() {\n+\t\tsuper.dispose();\n+\t\ttimestampedCollector = null;\n+\t\twatermarkTimers = null;\n+\t\twatermarkTimersQueue = null;\n+\t\tprocessingTimeTimers = null;\n+\t\tprocessingTimeTimersQueue = null;\n+\t\tcontext = null;\n+\t\tmergingWindowsByKey = null;\n \t}\n \n \t@Override\n@@ -231,15 +255,10 @@ public final void close() throws Exception {\n \tpublic void processElement(StreamRecord<IN> element) throws Exception {\n \t\tCollection<W> elementWindows = windowAssigner.assignWindows(element.getValue(), element.getTimestamp());\n \n-\t\tK key = (K) getStateBackend().getCurrentKey();\n+\t\tfinal K key = (K) getStateBackend().getCurrentKey();\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get(getStateBackend().getCurrentKey());\n-\t\t\tif (mergingWindows == null) {\n-\t\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner);\n-\t\t\t\tmergingWindowsByKey.put(key, mergingWindows);\n-\t\t\t}\n-\n+\t\t\tMergingWindowSet<W> mergingWindows = getMergingWindowSet();\n \n \t\t\tfor (W window: elementWindows) {\n \t\t\t\t// If there is a merge, it can only result in a window that contains our new\n@@ -255,6 +274,7 @@ public void processElement(StreamRecord<IN> element) throws Exception {\n \t\t\t\t\tpublic void merge(W mergeResult,\n \t\t\t\t\t\t\tCollection<W> mergedWindows, W stateWindowResult,\n \t\t\t\t\t\t\tCollection<W> mergedStateWindows) throws Exception {\n+\t\t\t\t\t\tcontext.key = key;\n \t\t\t\t\t\tcontext.window = mergeResult;\n \n \t\t\t\t\t\t// store for later use\n@@ -286,7 +306,7 @@ public void merge(W mergeResult,\n \n \t\t\t\tTriggerResult combinedTriggerResult = TriggerResult.merge(triggerResult, mergeTriggerResult.f0);\n \n-\t\t\t\tprocessTriggerResult(combinedTriggerResult, key, actualWindow);\n+\t\t\t\tprocessTriggerResult(combinedTriggerResult, actualWindow);\n \t\t\t}\n \n \t\t} else {\n@@ -301,13 +321,40 @@ public void merge(W mergeResult,\n \t\t\t\tcontext.window = window;\n \t\t\t\tTriggerResult triggerResult = context.onElement(element);\n \n-\t\t\t\tprocessTriggerResult(triggerResult, key, window);\n+\t\t\t\tprocessTriggerResult(triggerResult, window);\n \t\t\t}\n \t\t}\n \t}\n \n+\t/**\n+\t * Retrieves the {@link MergingWindowSet} for the currently active key. The caller must\n+\t * ensure that the correct key is set in the state backend.\n+\t */\n \t@SuppressWarnings(\"unchecked\")\n-\tprotected void processTriggerResult(TriggerResult triggerResult, K key, W window) throws Exception {\n+\tprotected MergingWindowSet<W> getMergingWindowSet() throws Exception {\n+\t\tMergingWindowSet<W> mergingWindows = mergingWindowsByKey.get((K) getStateBackend().getCurrentKey());\n+\t\tif (mergingWindows == null) {\n+\t\t\t// try to retrieve from state\n+\n+\t\t\tTupleSerializer<Tuple2<W, W>> tupleSerializer = new TupleSerializer<>((Class) Tuple2.class, new TypeSerializer[] {windowSerializer, windowSerializer} );\n+\t\t\tListStateDescriptor<Tuple2<W, W>> mergeStateDescriptor = new ListStateDescriptor<>(\"merging-window-set\", tupleSerializer);\n+\t\t\tListState<Tuple2<W, W>> mergeState = getStateBackend().getPartitionedState(null, VoidSerializer.INSTANCE, mergeStateDescriptor);\n+\n+\t\t\tmergingWindows = new MergingWindowSet<>((MergingWindowAssigner<? super IN, W>) windowAssigner, mergeState);\n+\t\t\tmergeState.clear();\n+\n+\t\t\tmergingWindowsByKey.put((K) getStateBackend().getCurrentKey(), mergingWindows);\n+\t\t}\n+\t\treturn mergingWindows;\n+\t}\n+\n+\n+\t/**\n+\t * Process {@link TriggerResult} for the currently active key and the given window. The caller\n+\t * must ensure that the correct key is set in the state backend and the context object.\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void processTriggerResult(TriggerResult triggerResult, W window) throws Exception {\n \t\tif (!triggerResult.isFire() && !triggerResult.isPurge()) {\n \t\t\t// do nothing\n \t\t\treturn;\n@@ -318,7 +365,7 @@ protected void processTriggerResult(TriggerResult triggerResult, K key, W window\n \t\tMergingWindowSet<W> mergingWindows = null;\n \n \t\tif (windowAssigner instanceof MergingWindowAssigner) {\n-\t\t\tmergingWindows = mergingWindowsByKey.get(key);\n+\t\t\tmergingWindows = getMergingWindowSet();\n \t\t\tW stateWindow = mergingWindows.getStateWindow(window);\n \t\t\twindowState = getPartitionedState(stateWindow, windowSerializer, windowStateDescriptor);\n \n@@ -366,7 +413,7 @@ private void processTriggersFor(Watermark mark) throws Exception {\n \t\t\t\tcontext.window = timer.window;\n \t\t\t\tsetKeyContext(timer.key);\n \t\t\t\tTriggerResult triggerResult = context.onEventTime(timer.timestamp);\n-\t\t\t\tprocessTriggerResult(triggerResult, context.key, context.window);\n+\t\t\t\tprocessTriggerResult(triggerResult, context.window);\n \t\t\t} else {\n \t\t\t\tfire = false;\n \t\t\t}\n@@ -389,7 +436,7 @@ public final void trigger(long time) throws Exception {\n \t\t\t\tcontext.window = timer.window;\n \t\t\t\tsetKeyContext(timer.key);\n \t\t\t\tTriggerResult triggerResult = context.onProcessingTime(timer.timestamp);\n-\t\t\t\tprocessTriggerResult(triggerResult, context.key, context.window);\n+\t\t\t\tprocessTriggerResult(triggerResult, context.window);\n \t\t\t} else {\n \t\t\t\tfire = false;\n \t\t\t}\n@@ -604,7 +651,20 @@ public String toString() {\n \t// ------------------------------------------------------------------------\n \n \t@Override\n+\t@SuppressWarnings(\"unchecked\")\n \tpublic StreamTaskState snapshotOperatorState(long checkpointId, long timestamp) throws Exception {\n+\n+\t\tif (mergingWindowsByKey != null) {\n+\t\t\tTupleSerializer<Tuple2<W, W>> tupleSerializer = new TupleSerializer<>((Class) Tuple2.class, new TypeSerializer[] {windowSerializer, windowSerializer} );\n+\t\t\tListStateDescriptor<Tuple2<W, W>> mergeStateDescriptor = new ListStateDescriptor<>(\"merging-window-set\", tupleSerializer);\n+\t\t\tfor (Map.Entry<K, MergingWindowSet<W>> key: mergingWindowsByKey.entrySet()) {\n+\t\t\t\tsetKeyContext(key.getKey());\n+\t\t\t\tListState<Tuple2<W, W>> mergeState = getStateBackend().getPartitionedState(null, VoidSerializer.INSTANCE, mergeStateDescriptor);\n+\t\t\t\tmergeState.clear();\n+\t\t\t\tkey.getValue().persist(mergeState);\n+\t\t\t}\n+\t\t}\n+\n \t\tStreamTaskState taskState = super.snapshotOperatorState(checkpointId, timestamp);\n \n \t\tAbstractStateBackend.CheckpointStateOutputView out =\n", 
  "project": "flink", 
  "linesAdd": 100, 
  "jira_id": "3740", 
  "nb_skipped": 1, 
  "commit": "f2f5bd5b", 
  "nb_failure": 1, 
  "linesRem": 23
}