{
  "files": 1, 
  "nb_test": 966, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "type.extractor.TypeExtractorTest"
  ], 
  "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 1ae8d3d62f..2e4510708d 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -18,6 +18,7 @@\n \n package org.apache.flink.api.java.typeutils;\n \n+import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.Method;\n@@ -1298,10 +1299,10 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\treturn true;\n \t\t\t} else {\n \t\t\t\tif(!hasGetter) {\n-\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a getter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(clazz+\" does not contain a getter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\tif(!hasSetter) {\n-\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a setter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(clazz+\" does not contain a setter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\treturn false;\n \t\t\t}\n@@ -1323,7 +1324,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\t\n \t\tList<Field> fields = getAllDeclaredFields(clazz);\n \t\tif(fields.size() == 0) {\n-\t\t\tLOG.info(\"No fields detected for class \" + clazz + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n+\t\t\tLOG.info(\"No fields detected for \" + clazz + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n \t\t}\n \n@@ -1331,7 +1332,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\tfor (Field field : fields) {\n \t\t\tType fieldType = field.getGenericType();\n \t\t\tif(!isValidPojoField(field, clazz, typeHierarchy)) {\n-\t\t\t\tLOG.info(\"Class \" + clazz + \" is not a valid POJO type\");\n+\t\t\t\tLOG.info(clazz + \" is not a valid POJO type\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\ttry {\n@@ -1357,24 +1358,29 @@ else if(typeHierarchy.size() <= 1) {\n \t\tList<Method> methods = getAllDeclaredMethods(clazz);\n \t\tfor (Method method : methods) {\n \t\t\tif (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n-\t\t\t\tLOG.info(\"Class \"+clazz+\" contains custom serialization methods we do not call.\");\n+\t\t\t\tLOG.info(clazz+\" contains custom serialization methods we do not call.\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t}\n \n \t\t// Try retrieving the default constructor, if it does not have one\n \t\t// we cannot use this because the serializer uses it.\n+\t\tConstructor defaultConstructor = null;\n \t\ttry {\n-\t\t\tclazz.getDeclaredConstructor();\n+\t\t\tdefaultConstructor = clazz.getDeclaredConstructor();\n \t\t} catch (NoSuchMethodException e) {\n \t\t\tif (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {\n-\t\t\t\tLOG.info(\"Class \" + clazz + \" is abstract or an interface, having a concrete \" +\n+\t\t\t\tLOG.info(clazz + \" is abstract or an interface, having a concrete \" +\n \t\t\t\t\t\t\"type can increase performance.\");\n \t\t\t} else {\n-\t\t\t\tLOG.info(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\n+\t\t\t\tLOG.info(clazz + \" must have a default constructor to be used as a POJO.\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t}\n+\t\tif(defaultConstructor != null && !Modifier.isPublic(defaultConstructor.getModifiers())) {\n+\t\t\tLOG.info(\"The default constructor of \" + clazz + \" should be Public to be used as a POJO.\");\n+\t\t\treturn null;\n+\t\t}\n \t\t\n \t\t// everything is checked, we return the pojo\n \t\treturn pojoType;\n@@ -1394,7 +1400,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\t\t\t\tcontinue; // we have no use for transient or static fields\n \t\t\t\t}\n \t\t\t\tif(hasFieldWithSameName(field.getName(), result)) {\n-\t\t\t\t\tthrow new RuntimeException(\"The field \"+field+\" is already contained in the hierarchy of the class \"+clazz+\".\"\n+\t\t\t\t\tthrow new RuntimeException(\"The field \"+field+\" is already contained in the hierarchy of the \"+clazz+\".\"\n \t\t\t\t\t\t\t+ \"Please use unique field names through your classes hierarchy\");\n \t\t\t\t}\n \t\t\t\tresult.add(field);\n", 
  "project": "flink", 
  "linesAdd": 15, 
  "jira_id": "2437", 
  "nb_skipped": 0, 
  "commit": "a41bc8cc", 
  "nb_failure": 1, 
  "linesRem": 9
}