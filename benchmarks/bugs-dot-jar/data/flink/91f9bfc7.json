{
  "files": 1, 
  "nb_test": 744, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "type.extractor.TypeExtractorTest"
  ], 
  "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 99292a6398..124055cc37 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -893,6 +893,10 @@ private static Type getTypeHierarchy(ArrayList<Type> typeHierarchy, Type curT, C\n \t\twhile (!(isClassType(curT) && typeToClass(curT).equals(stopAtClass))) {\n \t\t\ttypeHierarchy.add(curT);\n \t\t\tcurT = typeToClass(curT).getGenericSuperclass();\n+\n+\t\t\tif (curT == null) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\treturn curT;\n \t}\n@@ -1090,11 +1094,6 @@ private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeV\n \t\t\tParameterizedType parameterizedType, TypeInformation<IN1> in1Type, TypeInformation<IN2> in2Type) {\n \t\tValidate.notNull(clazz);\n \t\t\n-\t\t// check for abstract classes or interfaces\n-\t\tif (!clazz.isPrimitive() && (Modifier.isInterface(clazz.getModifiers()) || (Modifier.isAbstract(clazz.getModifiers()) && !clazz.isArray()))) {\n-\t\t\tthrow new InvalidTypesException(\"Interfaces and abstract classes are not valid types: \" + clazz);\n-\t\t}\n-\n \t\tif (clazz.equals(Object.class)) {\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n \t\t}\n@@ -1153,6 +1152,11 @@ private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeV\n \n \t\talreadySeen.add(clazz);\n \n+\t\tif (Modifier.isInterface(clazz.getModifiers())) {\n+\t\t\t// Interface has no members and is therefore not handled as POJO\n+\t\t\treturn new GenericTypeInfo<OUT>(clazz);\n+\t\t}\n+\n \t\tif (clazz.equals(Class.class)) {\n \t\t\t// special case handling for Class, this should not be handled by the POJO logic\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n@@ -1228,10 +1232,10 @@ private boolean isValidPojoField(Field f, Class<?> clazz, ArrayList<Type> typeHi\n \t\t\t\treturn true;\n \t\t\t} else {\n \t\t\t\tif(!hasGetter) {\n-\t\t\t\t\tLOG.warn(\"Class \"+clazz+\" does not contain a getter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a getter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\tif(!hasSetter) {\n-\t\t\t\t\tLOG.warn(\"Class \"+clazz+\" does not contain a setter for field \"+f.getName() );\n+\t\t\t\t\tLOG.debug(\"Class \"+clazz+\" does not contain a setter for field \"+f.getName() );\n \t\t\t\t}\n \t\t\t\treturn false;\n \t\t\t}\n@@ -1251,11 +1255,16 @@ else if(typeHierarchy.size() <= 1) {\n \t\t}\n \t\t\n \t\tList<Field> fields = getAllDeclaredFields(clazz);\n+\t\tif(fields.size() == 0) {\n+\t\t\tLOG.info(\"No fields detected for class \" + clazz + \". Cannot be used as a PojoType. Will be handled as GenericType\");\n+\t\t\treturn new GenericTypeInfo<OUT>(clazz);\n+\t\t}\n+\n \t\tList<PojoField> pojoFields = new ArrayList<PojoField>();\n \t\tfor (Field field : fields) {\n \t\t\tType fieldType = field.getGenericType();\n \t\t\tif(!isValidPojoField(field, clazz, typeHierarchy)) {\n-\t\t\t\tLOG.warn(\"Class \"+clazz+\" is not a valid POJO type\");\n+\t\t\t\tLOG.info(\"Class \" + clazz + \" is not a valid POJO type\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t\ttry {\n@@ -1281,7 +1290,7 @@ else if(typeHierarchy.size() <= 1) {\n \t\tList<Method> methods = getAllDeclaredMethods(clazz);\n \t\tfor (Method method : methods) {\n \t\t\tif (method.getName().equals(\"readObject\") || method.getName().equals(\"writeObject\")) {\n-\t\t\t\tLOG.warn(\"Class \"+clazz+\" contains custom serialization methods we do not call.\");\n+\t\t\t\tLOG.info(\"Class \"+clazz+\" contains custom serialization methods we do not call.\");\n \t\t\t\treturn null;\n \t\t\t}\n \t\t}\n@@ -1291,9 +1300,14 @@ else if(typeHierarchy.size() <= 1) {\n \t\ttry {\n \t\t\tclazz.getDeclaredConstructor();\n \t\t} catch (NoSuchMethodException e) {\n-\t\t\tLOG.warn(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\n+\t\t\tif (clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers())) {\n+\t\t\t\tLOG.info(\"Class \" + clazz + \" is abstract or an interface, having a concrete \" +\n+\t\t\t\t\t\t\"type can increase performance.\");\n+\t\t\t} else {\n+\t\t\t\tLOG.info(\"Class \" + clazz + \" must have a default constructor to be used as a POJO.\");\n \t\t\t\treturn null;\n \t\t\t}\n+\t\t}\n \t\t\n \t\t// everything is checked, we return the pojo\n \t\treturn pojoType;\n", 
  "project": "flink", 
  "linesAdd": 24, 
  "jira_id": "1458", 
  "nb_skipped": 0, 
  "commit": "91f9bfc7", 
  "nb_failure": 1, 
  "linesRem": 10
}