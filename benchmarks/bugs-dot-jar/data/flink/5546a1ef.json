{
  "files": 1, 
  "nb_test": 966, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "type.extractor.PojoTypeExtractionTest"
  ], 
  "patch": "diff --git a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\nindex 41644f9c16..1ae8d3d62f 100644\n--- a/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n+++ b/flink-java/src/main/java/org/apache/flink/api/java/typeutils/TypeExtractor.java\n@@ -26,9 +26,7 @@\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n import java.util.ArrayList;\n-import java.util.HashSet;\n import java.util.List;\n-import java.util.Set;\n \n import org.apache.avro.specific.SpecificRecordBase;\n import org.apache.flink.api.common.functions.CoGroupFunction;\n@@ -67,14 +65,32 @@\n  */\n public class TypeExtractor {\n \n-\tprivate static final Logger LOG = LoggerFactory.getLogger(TypeExtractor.class);\n+\t/*\n+\t * NOTE: Most methods of the TypeExtractor work with a so-called \"typeHierarchy\".\n+\t * The type hierarchy describes all types (Classes, ParameterizedTypes, TypeVariables etc. ) and intermediate\n+\t * types from a given type of a function or type (e.g. MyMapper, Tuple2) until a current type\n+\t * (depends on the method, e.g. MyPojoFieldType).\n+\t *\n+\t * Thus, it fully qualifies types until tuple/POJO field level.\n+\t *\n+\t * A typical typeHierarchy could look like:\n+\t *\n+\t * UDF: MyMapFunction.class\n+\t * top-level UDF: MyMapFunctionBase.class\n+\t * RichMapFunction: RichMapFunction.class\n+\t * MapFunction: MapFunction.class\n+\t * Function's OUT: Tuple1<MyPojo>\n+\t * user-defined POJO: MyPojo.class\n+\t * user-defined top-level POJO: MyPojoBase.class\n+\t * POJO field: Tuple1<String>\n+\t * Field type: String.class\n+\t *\n+\t */\n \t\n-\t// We need this to detect recursive types and not get caught\n-\t// in an endless recursion\n-\tprivate Set<Class<?>> alreadySeen;\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(TypeExtractor.class);\n \n \tprotected TypeExtractor() {\n-\t\talreadySeen = new HashSet<Class<?>>();\n+\t\t// only create instances for special use cases\n \t}\n \n \t// --------------------------------------------------------------------------------------------\n@@ -416,10 +432,12 @@ protected TypeExtractor() {\n \t\t\t\n \t\t\tTypeInformation<?>[] tupleSubTypes = new TypeInformation<?>[subtypes.length];\n \t\t\tfor (int i = 0; i < subtypes.length; i++) {\n+\t\t\t\tArrayList<Type> subTypeHierarchy = new ArrayList<Type>(typeHierarchy);\n+\t\t\t\tsubTypeHierarchy.add(subtypes[i]);\n \t\t\t\t// sub type could not be determined with materializing\n \t\t\t\t// try to derive the type info of the TypeVariable from the immediate base child input as a last attempt\n \t\t\t\tif (subtypes[i] instanceof TypeVariable<?>) {\n-\t\t\t\t\ttupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], typeHierarchy, in1Type, in2Type);\n+\t\t\t\t\ttupleSubTypes[i] = createTypeInfoFromInputs((TypeVariable<?>) subtypes[i], subTypeHierarchy, in1Type, in2Type);\n \t\t\t\t\t\n \t\t\t\t\t// variable could not be determined\n \t\t\t\t\tif (tupleSubTypes[i] == null) {\n@@ -430,7 +448,7 @@ protected TypeExtractor() {\n \t\t\t\t\t\t\t\t+ \"all variables in the return type can be deduced from the input type(s).\");\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\ttupleSubTypes[i] = createTypeInfoWithTypeHierarchy(new ArrayList<Type>(typeHierarchy), subtypes[i], in1Type, in2Type);\n+\t\t\t\t\ttupleSubTypes[i] = createTypeInfoWithTypeHierarchy(subTypeHierarchy, subtypes[i], in1Type, in2Type);\n \t\t\t\t}\n \t\t\t}\n \t\t\t\n@@ -913,6 +931,19 @@ else if (typeInfo instanceof GenericTypeInfo<?>) {\n \t//  Utility methods\n \t// --------------------------------------------------------------------------------------------\n \n+\t/**\n+\t * @return number of items with equal type or same raw type\n+\t */\n+\tprivate static int countTypeInHierarchy(ArrayList<Type> typeHierarchy, Type type) {\n+\t\tint count = 0;\n+\t\tfor (Type t : typeHierarchy) {\n+\t\t\tif (t == type || (isClassType(type) && t == typeToClass(type))) {\n+\t\t\t\tcount++;\n+\t\t\t}\n+\t\t}\n+\t\treturn count;\n+\t}\n+\t\n \t/**\n \t * @param curT : start type\n \t * @return Type The immediate child of the top class\n@@ -1183,12 +1214,10 @@ private static Type materializeTypeVariable(ArrayList<Type> typeHierarchy, TypeV\n \t\t\treturn (TypeInformation<OUT>) new AvroTypeInfo(clazz);\n \t\t}\n \n-\t\tif (alreadySeen.contains(clazz)) {\n+\t\tif (countTypeInHierarchy(typeHierarchy, clazz) > 1) {\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n \t\t}\n \n-\t\talreadySeen.add(clazz);\n-\n \t\tif (Modifier.isInterface(clazz.getModifiers())) {\n \t\t\t// Interface has no members and is therefore not handled as POJO\n \t\t\treturn new GenericTypeInfo<OUT>(clazz);\n", 
  "project": "flink", 
  "linesAdd": 41, 
  "jira_id": "2447", 
  "nb_skipped": 0, 
  "commit": "5546a1ef", 
  "nb_failure": 1, 
  "linesRem": 12
}