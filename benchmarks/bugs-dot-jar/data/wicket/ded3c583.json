{
  "files": 1, 
  "nb_test": 1703, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.wicket.core.request.mapper.CryptoMapperTest", 
    "org.apache.wicket.settings.ISecuritySettingsTest"
  ], 
  "patch": "diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\nindex 05e7c30865..99f7afc878 100755\n--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java\n@@ -16,6 +16,7 @@\n  */\r\n package org.apache.wicket.core.request.mapper;\r\n \r\n+import java.util.Iterator;\r\n import java.util.List;\r\n \r\n import org.apache.wicket.Application;\r\n@@ -25,6 +26,7 @@\n import org.apache.wicket.request.Request;\r\n import org.apache.wicket.request.Url;\r\n import org.apache.wicket.request.mapper.IRequestMapperDelegate;\r\n+import org.apache.wicket.request.mapper.info.PageComponentInfo;\r\n import org.apache.wicket.util.IProvider;\r\n import org.apache.wicket.util.crypt.ICrypt;\r\n import org.apache.wicket.util.crypt.ICryptFactory;\r\n@@ -34,16 +37,37 @@\n import org.slf4j.LoggerFactory;\r\n \r\n /**\r\n- * Request mapper that encrypts urls generated by another mapper. The original URL (both segments\r\n- * and parameters) is encrypted and is represented as URL segment. To be able to handle relative\r\n- * URLs for images in .css file the same amount of URL segments that the original URL had are\r\n- * appended to the encrypted URL. Each segment has a precise 5 character value, calculated using a\r\n- * checksum. This helps in calculating the relative distance from the original URL. When a URL is\r\n- * returned by the browser, we iterate through these checksummed placeholder URL segments. If the\r\n- * segment matches the expected checksum, then the segment it deemed to be the corresponding segment\r\n- * in the encrypted URL. If the segment does not match the expected checksum, then the segment is\r\n- * deemed a plain text sibling of the corresponding segment in the encrypted URL, and all subsequent\r\n+ * <p>\r\n+ * A request mapper that encrypts URLs generated by another mapper. This mapper encrypts the segments\r\n+ * and query parameters of URLs starting with {@code /wicket/}, and the just the {@link PageComponentInfo}\r\n+ * parameter for mounted URLs.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * This mapper can be mounted before or after mounting other pages, but will only encrypt URLs for\r\n+ * pages mounted before the {@link CryptoMapper}. If required, multiple {@link CryptoMapper}s may be\r\n+ * installed in an {@link Application}.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * When encrypting URLs in the Wicket namespace (starting with {@code /wicket/}), the entire URL, including\r\n+ * segments and parameters, is encrypted, with the encrypted form stored in the first segment of the encrypted URL.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * To be able to handle relative URLs, like for image URLs in a CSS file, checksum segments are appended to the\r\n+ * encrypted URL until the encrypted URL has the same number of segments as the original URL had.\r\n+ * Each checksum segment has a precise 5 character value, calculated using a checksum. This helps in calculating\r\n+ * the relative distance from the original URL. When a URL is returned by the browser, we iterate through these\r\n+ * checksummed placeholder URL segments. If the segment matches the expected checksum, then the segment it deemed\r\n+ * to be the corresponding segment in the original URL. If the segment does not match the expected checksum, then\r\n+ * the segment is deemed a plain text sibling of the corresponding segment in the original URL, and all subsequent\r\n  * segments are considered plain text children of the current segment.\r\n+ * </p>\r\n+ * \r\n+ * <p>\r\n+ * When encrypting mounted URLs, we look for the {@link PageComponentInfo} parameter, and encrypt only that parameter.\r\n+ * </p>\r\n  * \r\n  * @author igor.vaynberg\r\n  * @author Jesse Long\r\n@@ -53,6 +77,11 @@\n {\r\n \tprivate static final Logger log = LoggerFactory.getLogger(CryptoMapper.class);\r\n \r\n+\t/**\r\n+\t * Name of the parameter which contains encrypted page component info.\r\n+\t */\r\n+\tprivate static final String ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER = \"wicket\";\r\n+\r\n \tprivate final IRequestMapper wrappedMapper;\r\n \tprivate final IProvider<ICrypt> cryptProvider;\r\n \r\n@@ -87,12 +116,34 @@ public CryptoMapper(final IRequestMapper wrappedMapper, final IProvider<ICrypt>\n \t\tthis.cryptProvider = Args.notNull(cryptProvider, \"cryptProvider\");\r\n \t}\r\n \r\n+\t/**\r\n+\t * {@inheritDoc}\r\n+\t * <p>\r\n+\t * This implementation decrypts the URL and passes the decrypted URL to the wrapped mapper.\r\n+\t * </p>\r\n+\t * @param request\r\n+\t *\t\tThe request for which to get a compatability score.\r\n+\t * \r\n+\t * @return The compatability score.\r\n+\t */\r\n \t@Override\r\n \tpublic int getCompatibilityScore(final Request request)\r\n \t{\r\n-\t\treturn wrappedMapper.getCompatibilityScore(request);\r\n+\t\tUrl decryptedUrl = decryptUrl(request, request.getUrl());\r\n+\r\n+\t\tif (decryptedUrl == null)\r\n+\t\t{\r\n+\t\t\treturn 0;\r\n \t\t}\r\n \r\n+\t\tRequest decryptedRequest = request.cloneWithUrl(decryptedUrl);\r\n+\r\n+\t\treturn wrappedMapper.getCompatibilityScore(decryptedRequest);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * {@inheritDoc}\r\n+\t */\r\n \t@Override\r\n \tpublic Url mapHandler(final IRequestHandler requestHandler)\r\n \t{\r\n@@ -112,6 +163,9 @@ public Url mapHandler(final IRequestHandler requestHandler)\n \t\treturn encryptUrl(url);\r\n \t}\r\n \r\n+\t/**\r\n+\t * {@inheritDoc}\r\n+\t */\r\n \t@Override\r\n \tpublic IRequestHandler mapRequest(final Request request)\r\n \t{\r\n@@ -119,7 +173,7 @@ public IRequestHandler mapRequest(final Request request)\n \r\n \t\tif (url == null)\r\n \t\t{\r\n-\t\t\treturn wrappedMapper.mapRequest(request);\r\n+\t\t\treturn null;\r\n \t\t}\r\n \r\n \t\tRequest decryptedRequest = request.cloneWithUrl(url);\r\n@@ -152,18 +206,44 @@ public final IRequestMapper getDelegateMapper()\n \t\treturn wrappedMapper;\r\n \t}\r\n \r\n+\t/**\r\n+\t * Encrypts a URL. This method should return a new, encrypted instance of the URL. If the URL starts with {@code /wicket/},\r\n+\t * the entire URL is encrypted.\r\n+\t * \r\n+\t * @param url\r\n+\t *\t\tThe URL to encrypt.\r\n+\t * \r\n+\t * @return A new, encrypted version of the URL.\r\n+\t */\r\n \tprotected Url encryptUrl(final Url url)\r\n \t{\r\n-\t\tif (url.getSegments().isEmpty())\r\n+\t\tif (url.getSegments().size() > 0\r\n+\t\t\t&& url.getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))\r\n \t\t{\r\n-\t\t\treturn url;\r\n+\t\t\treturn encryptEntireUrl(url);\r\n \t\t}\r\n+\t\telse\r\n+\t\t{\r\n+\t\t\treturn encryptRequestListenerParameter(url);\r\n+\t\t}\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Encrypts an entire URL, segments and query parameters.\r\n+\t * \r\n+\t * @param url\r\n+\t *\t\tThe URL to encrypt.\r\n+\t * \r\n+\t * @return An encrypted form of the URL.\r\n+\t */\r\n+\tprotected Url encryptEntireUrl(final Url url)\r\n+\t{\r\n \t\tString encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());\r\n \r\n \t\tUrl encryptedUrl = new Url(url.getCharset());\r\n \t\tencryptedUrl.getSegments().add(encryptedUrlString);\r\n \r\n-\t\tint numberOfSegments = url.getSegments().size();\r\n+\t\tint numberOfSegments = url.getSegments().size() - 1;\r\n \t\tHashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n \t\tfor (int segNo = 0; segNo < numberOfSegments; segNo++)\r\n \t\t{\r\n@@ -172,25 +252,108 @@ protected Url encryptUrl(final Url url)\n \t\treturn encryptedUrl;\r\n \t}\r\n \r\n+\t/**\r\n+\t * Encrypts the {@link PageComponentInfo} query parameter in the URL, if any is found.\r\n+\t * \r\n+\t * @param url\r\n+\t *\t\tThe URL to encrypt.\r\n+\t * \r\n+\t * @return An encrypted form of the URL.\r\n+\t */\r\n+\tprotected Url encryptRequestListenerParameter(final Url url)\r\n+\t{\r\n+\t\tUrl encryptedUrl = new Url(url);\r\n+\r\n+\t\tfor (Iterator<Url.QueryParameter> it = encryptedUrl.getQueryParameters().iterator(); it.hasNext();)\r\n+\t\t{\r\n+\t\t\tUrl.QueryParameter qp = it.next();\r\n+\r\n+\t\t\tif (Strings.isEmpty(qp.getValue()) == true && Strings.isEmpty(qp.getName()) == false)\r\n+\t\t\t{\r\n+\t\t\t\tif (PageComponentInfo.parse(qp.getName()) != null)\r\n+\t\t\t\t{\r\n+\t\t\t\t\tit.remove();\r\n+\t\t\t\t\tString encryptedParameterValue = getCrypt().encryptUrlSafe(qp.getName());\r\n+\t\t\t\t\tUrl.QueryParameter encryptedParameter\r\n+\t\t\t\t\t\t= new Url.QueryParameter(ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER, encryptedParameterValue);\r\n+\t\t\t\t\tencryptedUrl.getQueryParameters().add(0, encryptedParameter);\r\n+\t\t\t\t\tbreak;\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n+\r\n+\t\treturn encryptedUrl;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Decrypts a {@link Url}. This method should return {@code null} if the URL is not decryptable, or if the\r\n+\t * URL should have been encrypted but was not. Returning {@code null} results in a 404 error.\r\n+\t * \r\n+\t * @param request\r\n+\t *\t\tThe {@link Request}.\r\n+\t * @param encryptedUrl\r\n+\t *\t\tThe encrypted {@link Url}.\r\n+\t * \r\n+\t * @return Returns a decrypted {@link Url}.\r\n+\t */\r\n \tprotected Url decryptUrl(final Request request, final Url encryptedUrl)\r\n+\t{\r\n+\t\tUrl url = decryptEntireUrl(request, encryptedUrl);\r\n+\r\n+\t\tif (url == null)\r\n+\t\t{\r\n+\t\t\tif (encryptedUrl.getSegments().size() > 0\r\n+\t\t\t\t&& encryptedUrl.getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))\r\n \t\t\t{\r\n \t\t\t\t/*\r\n-\t\t * If the encrypted URL has no segments it is the home page URL, and does not need\r\n-\t\t * decrypting.\r\n+\t\t\t\t * This URL should have been encrypted, but was not. We should refuse to handle this, except when\r\n+\t\t\t\t * there is more than one CryptoMapper installed, and the request was decrypted by some other\r\n+\t\t\t\t * CryptoMapper.\r\n \t\t\t\t */\r\n-\t\tif (encryptedUrl.getSegments().isEmpty())\r\n+\t\t\t\tif (request.getOriginalUrl().getSegments().size() > 0\r\n+\t\t\t\t\t&& request.getOriginalUrl().getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))\r\n+\t\t\t\t{\r\n+\t\t\t\t\treturn null;\r\n+\t\t\t\t}\r\n+\t\t\t\telse\r\n \t\t\t\t{\r\n \t\t\t\t\treturn encryptedUrl;\r\n \t\t\t\t}\r\n+\t\t\t}\r\n+\t\t}\r\n \r\n-\t\tList<String> encryptedSegments = encryptedUrl.getSegments();\r\n+\t\tif (url == null)\r\n+\t\t{\r\n+\t\t\turl = decryptRequestListenerParameter(request, encryptedUrl);\r\n+\t\t}\r\n \r\n+\t\treturn url;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Decrypts an entire URL, which was previously encrypted by {@link #encryptEntireUrl(org.apache.wicket.request.Url)}.\r\n+\t * This method should return {@code null} if the URL is not decryptable.\r\n+\t * \r\n+\t * @param request\r\n+\t *\t\tThe request that was made.\r\n+\t * @param encryptedUrl\r\n+\t *\t\tThe encrypted URL.\r\n+\t * \r\n+\t * @return A decrypted form of the URL, or {@code null} if the URL is not decryptable.\r\n+\t */\r\n+\tprotected Url decryptEntireUrl(final Request request, final Url encryptedUrl)\r\n+\t{\r\n \t\tUrl url = new Url(request.getCharset());\r\n-\t\ttry\r\n+\r\n+\t\tList<String> encryptedSegments = encryptedUrl.getSegments();\r\n+\r\n+\t\tif (encryptedSegments.isEmpty())\r\n \t\t{\r\n+\t\t\treturn null;\r\n+\t\t}\r\n+\r\n \t\t/*\r\n-\t\t\t * The first encrypted segment contains an encrypted version of the entire plain text\r\n-\t\t\t * url.\r\n+\t\t * The first encrypted segment contains an encrypted version of the entire plain text url.\r\n \t\t */\r\n \t\tString encryptedUrlString = encryptedSegments.get(0);\r\n \t\tif (Strings.isEmpty(encryptedUrlString))\r\n@@ -198,7 +361,17 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\treturn null;\r\n \t\t}\r\n \r\n-\t\t\tString decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n+\t\tString decryptedUrl;\r\n+\t\ttry\r\n+\t\t{\r\n+\t\t\tdecryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);\r\n+\t\t}\r\n+\t\tcatch (Exception e)\r\n+\t\t{\r\n+\t\t\tlog.error(\"Error decrypting URL\", e);\r\n+\t\t\treturn null;\r\n+\t\t}\r\n+\r\n \t\tif (decryptedUrl == null)\r\n \t\t{\r\n \t\t\treturn null;\r\n@@ -208,6 +382,28 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\tint originalNumberOfSegments = originalUrl.getSegments().size();\r\n \t\tint encryptedNumberOfSegments = encryptedUrl.getSegments().size();\r\n \r\n+\t\tif (originalNumberOfSegments > 0)\r\n+\t\t{\r\n+\t\t\t/*\r\n+\t\t\t * This should always be true. Home page URLs are the only ones without\r\n+\t\t\t * segments, and we dont encrypt those with this method.\r\n+\t\t\t * \r\n+\t\t\t * We always add the first segment of the URL, because we encrypt a URL like:\r\n+\t\t\t *\t/path/to/something\r\n+\t\t\t * to:\r\n+\t\t\t *\t/encrypted_full/hash/hash\r\n+\t\t\t * \r\n+\t\t\t * Notice the consistent number of segments. If we applied the following relative URL:\r\n+\t\t\t *\t../../something\r\n+\t\t\t * then the resultant URL would be:\r\n+\t\t\t *\t/something\r\n+\t\t\t * \r\n+\t\t\t * Hence, the mere existence of the first, encrypted version of complete URL, segment\r\n+\t\t\t * tells us that the first segment of the original URL is still to be used.\r\n+\t\t\t */\r\n+\t\t\turl.getSegments().add(originalUrl.getSegments().get(0));\r\n+\t\t}\r\n+\r\n \t\tHashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);\r\n \t\tint segNo = 1;\r\n \t\tfor (; segNo < encryptedNumberOfSegments; segNo++)\r\n@@ -222,18 +418,18 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\t\tif (!next.equals(encryptedSegment))\r\n \t\t\t{\r\n \t\t\t\t/*\r\n-\t\t\t\t\t * This segment received from the browser is not the same as the expected\r\n-\t\t\t\t\t * segment generated by the HashSegmentGenerator. Hence it, and all subsequent\r\n-\t\t\t\t\t * segments are considered plain text siblings of the original encrypted url.\r\n+\t\t\t\t * This segment received from the browser is not the same as the expected segment generated\r\n+\t\t\t\t * by the HashSegmentGenerator. Hence it, and all subsequent segments are considered plain\r\n+\t\t\t\t * text siblings of the original encrypted url.\r\n \t\t\t\t */\r\n \t\t\t\tbreak;\r\n \t\t\t}\r\n \r\n \t\t\t/*\r\n-\t\t\t\t * This segments matches the expected checksum, so we add the corresponding segment\r\n-\t\t\t\t * from the original URL.\r\n+\t\t\t * This segments matches the expected checksum, so we add the corresponding segment from the\r\n+\t\t\t * original URL.\r\n \t\t\t */\r\n-\t\t\t\turl.getSegments().add(originalUrl.getSegments().get(segNo - 1));\r\n+\t\t\turl.getSegments().add(originalUrl.getSegments().get(segNo));\r\n \t\t}\r\n \t\t/*\r\n \t\t * Add all remaining segments from the encrypted url as plain text segments.\r\n@@ -247,11 +443,83 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)\n \t\turl.getQueryParameters().addAll(originalUrl.getQueryParameters());\r\n \t\t// WICKET-4923 additional parameters\r\n \t\turl.getQueryParameters().addAll(encryptedUrl.getQueryParameters());\r\n+\r\n+\t\treturn url;\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Decrypts a URL which may contain an encrypted {@link PageComponentInfo} query parameter.\r\n+\t * \r\n+\t * @param request\r\n+\t *\t\tThe request that was made.\r\n+\t * @param encryptedUrl\r\n+\t *\t\tThe (potentially) encrypted URL.\r\n+\t * \r\n+\t * @return A decrypted form of the URL.\r\n+\t */\r\n+\tprotected Url decryptRequestListenerParameter(final Request request, Url encryptedUrl)\r\n+\t{\r\n+\t\tUrl url = new Url(encryptedUrl);\r\n+\r\n+\t\turl.getQueryParameters().clear();\r\n+\r\n+\t\tfor (Url.QueryParameter qp : encryptedUrl.getQueryParameters())\r\n+\t\t{\r\n+\t\t\tif (Strings.isEmpty(qp.getValue()) && Strings.isEmpty(qp.getName()) == false)\r\n+\t\t\t{\r\n+\t\t\t\tif (PageComponentInfo.parse(qp.getName()) != null)\r\n+\t\t\t\t{\r\n+\t\t\t\t\t/*\r\n+\t\t\t\t\t * Plain text request listener parameter found. This should have been encrypted, so we\r\n+\t\t\t\t\t * refuse to map the request unless the original URL did not include this parameter, which\r\n+\t\t\t\t\t * case there are likely to be multiple cryptomappers installed.\r\n+\t\t\t\t\t */\r\n+\t\t\t\t\tif (request.getOriginalUrl().getQueryParameter(qp.getName()) == null)\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\treturn null;\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\telse if (ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER.equals(qp.getName()))\r\n+\t\t\t{\r\n+\t\t\t\tString encryptedValue = qp.getValue();\r\n+\r\n+\t\t\t\tif (Strings.isEmpty(encryptedValue))\r\n+\t\t\t\t{\r\n+\t\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t\t}\r\n+\t\t\t\telse\r\n+\t\t\t\t{\r\n+\t\t\t\t\tString decryptedValue = null;\r\n+\r\n+\t\t\t\t\ttry\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\tdecryptedValue = getCrypt().decryptUrlSafe(encryptedValue);\r\n \t\t\t\t\t}\r\n \t\t\t\t\tcatch (Exception e)\r\n \t\t\t\t\t{\r\n-\t\t\tlog.error(\"Error decrypting URL\", e);\r\n-\t\t\turl = null;\r\n+\t\t\t\t\t\tlog.error(\"Error decrypting encrypted request listener query parameter\", e);\r\n+\t\t\t\t\t}\r\n+\r\n+\t\t\t\t\tif (Strings.isEmpty(decryptedValue))\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t\telse\r\n+\t\t\t\t\t{\r\n+\t\t\t\t\t\tUrl.QueryParameter decryptedParamter = new Url.QueryParameter(decryptedValue, \"\");\r\n+\t\t\t\t\t\turl.getQueryParameters().add(0, decryptedParamter);\r\n+\t\t\t\t\t}\r\n+\t\t\t\t}\r\n+\t\t\t}\r\n+\t\t\telse\r\n+\t\t\t{\r\n+\t\t\t\turl.getQueryParameters().add(qp);\r\n+\t\t\t}\r\n \t\t}\r\n \r\n \t\treturn url;\r\n", 
  "project": "wicket", 
  "linesAdd": 296, 
  "jira_id": "5326", 
  "nb_skipped": 1, 
  "commit": "ded3c583", 
  "nb_failure": 15, 
  "linesRem": 30
}