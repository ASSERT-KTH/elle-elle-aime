{
  "files": 9, 
  "nb_test": 409, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "wicket.util.tester.apps_4.FormTesterTest", 
    "wicket.util.tester.WicketTesterTest"
  ], 
  "patch": "diff --git a/jdk-1.4/wicket/src/main/java/wicket/Component.java b/jdk-1.4/wicket/src/main/java/wicket/Component.java\nindex cd199158fb..a360e4f575 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/Component.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/Component.java\n@@ -662,7 +662,7 @@ public final boolean continueToOriginalDestination()\n \t */\n \tpublic final void debug(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().debug(this, message);\n+\t\tSession.get().getFeedbackMessages().debug(this, message);\n \t}\n \n \t/**\n@@ -685,7 +685,7 @@ public void detachModels()\n \t */\n \tpublic final void error(final Serializable message)\n \t{\n-\t\tgetPage().getFeedbackMessages().error(this, message);\n+\t\tSession.get().getFeedbackMessages().error(this, message);\n \t}\n \n \t/**\n@@ -696,7 +696,7 @@ public final void error(final Serializable message)\n \t */\n \tpublic final void fatal(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().fatal(this, message);\n+\t\tSession.get().getFeedbackMessages().fatal(this, message);\n \t}\n \n \t/**\n@@ -825,7 +825,7 @@ public final boolean getEscapeModelStrings()\n \t */\n \tpublic final FeedbackMessage getFeedbackMessage()\n \t{\n-\t\treturn getPage().getFeedbackMessages().messageForComponent(this);\n+\t\treturn Session.get().getFeedbackMessages().messageForComponent(this);\n \t}\n \n \t/**\n@@ -1216,7 +1216,7 @@ public String getVariation()\n \t */\n \tpublic final boolean hasErrorMessage()\n \t{\n-\t\treturn getPage().getFeedbackMessages().hasErrorMessageFor(this);\n+\t\treturn Session.get().getFeedbackMessages().hasErrorMessageFor(this);\n \t}\n \n \t/**\n@@ -1224,7 +1224,7 @@ public final boolean hasErrorMessage()\n \t */\n \tpublic final boolean hasFeedbackMessage()\n \t{\n-\t\treturn getPage().getFeedbackMessages().hasMessageFor(this);\n+\t\treturn Session.get().getFeedbackMessages().hasMessageFor(this);\n \t}\n \n \t/**\n@@ -1235,7 +1235,7 @@ public final boolean hasFeedbackMessage()\n \t */\n \tpublic final void info(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().info(this, message);\n+\t\tSession.get().getFeedbackMessages().info(this, message);\n \t}\n \n \t/**\n@@ -2376,7 +2376,7 @@ public final CharSequence urlFor(final ResourceReference resourceReference)\n \t */\n \tpublic final void warn(final String message)\n \t{\n-\t\tgetPage().getFeedbackMessages().warn(this, message);\n+\t\tSession.get().getFeedbackMessages().warn(this, message);\n \t}\n \n \t/**\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/Page.java b/jdk-1.4/wicket/src/main/java/wicket/Page.java\nindex c67365cf4d..24c9a2cfa7 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/Page.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/Page.java\n@@ -25,7 +25,6 @@\n import org.apache.commons.logging.LogFactory;\n \n import wicket.authorization.UnauthorizedActionException;\n-import wicket.feedback.FeedbackMessages;\n import wicket.feedback.IFeedback;\n import wicket.markup.MarkupException;\n import wicket.markup.MarkupStream;\n@@ -134,6 +133,12 @@\n  */\n public abstract class Page extends MarkupContainer implements IRedirectListener, IPageMapEntry\n {\n+\t/**\n+\t * When passed to {@link Page#getVersion(int)} the latest page version is\n+\t * returned.\n+\t */\n+\tpublic static final int LATEST_VERSION = -1;\n+\n \tprivate static final long serialVersionUID = 1L;\n \n \t/**\n@@ -141,12 +146,6 @@\n \t */\n \tprivate static final ConcurrentHashMap pageClassToBookmarkableCache = new ConcurrentHashMap();\n \n-\t/**\n-\t * When passed to {@link Page#getVersion(int)} the latest page version is\n-\t * returned.\n-\t */\n-\tpublic static final int LATEST_VERSION = -1;\n-\n \t/** True if this page is currently rendering. */\n \tprivate static final short FLAG_IS_RENDERING = FLAG_RESERVED2;\n \n@@ -165,9 +164,6 @@\n \t/** Used to create page-unique numbers */\n \tprivate short autoIndex;\n \n-\t/** Feedback messages for this page */\n-\tprivate FeedbackMessages feedbackMessages;\n-\n \t/** Numeric version of this page's id */\n \tprivate short numericId;\n \n@@ -283,6 +279,35 @@ public void beforeCallComponent(final Component component,\n \t}\n \n \n+\t/**\n+\t * Adds a component to the set of rendered components.\n+\t * \n+\t * @param component\n+\t *            The component that was rendered\n+\t */\n+\tpublic final void componentRendered(final Component component)\n+\t{\n+\t\t// Inform the page that this component rendered\n+\t\tif (Application.get().getDebugSettings().getComponentUseCheck())\n+\t\t{\n+\t\t\tif (renderedComponents == null)\n+\t\t\t{\n+\t\t\t\trenderedComponents = new HashSet();\n+\t\t\t}\n+\t\t\tif (renderedComponents.add(component) == false)\n+\t\t\t{\n+\t\t\t\tthrow new MarkupException(\n+\t\t\t\t\t\t\"The component \"\n+\t\t\t\t\t\t\t\t+ component\n+\t\t\t\t\t\t\t\t+ \" has the same wicket:id as another component already added at the same level\");\n+\t\t\t}\n+\t\t\tif (log.isDebugEnabled())\n+\t\t\t{\n+\t\t\t\tlog.debug(\"Rendered \" + component);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t/**\n \t * Detaches any attached models referenced by this page.\n \t */\n@@ -300,7 +325,8 @@ public void detachModels()\n \t\t// }\n \t\t// catch (Exception e) // catch anything; we MUST detach all models\n \t\t// {\n-//\t\t\t\t\tlog.error(\"detaching models of component \" + component + \" failed:\", e);\n+\t\t// log.error(\"detaching models of component \" + component + \" failed:\",\n+\t\t// e);\n \t\t// }\n \t\t// return IVisitor.CONTINUE_TRAVERSAL;\n \t\t// }\n@@ -317,88 +343,6 @@ public final void dirty()\n \t\tSession.get().dirtyPage(this);\n \t}\n \n-\t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL IT.\n-\t */\n-\tpublic final void renderPage()\n-\t{\n-\t\t// first try to check if the page can be rendered:\n-\t\tif (!isActionAuthorized(RENDER))\n-\t\t{\n-\t\t\tif (log.isDebugEnabled())\n-\t\t\t{\n-\t\t\t\tlog.debug(\"Page not allowed to render: \" + this);\n-\t\t\t}\n-\t\t\tthrow new UnauthorizedActionException(this, Component.RENDER);\n-\t\t}\n-\n-\t\t// Make sure it is really empty\n-\t\trenderedComponents = null;\n-\n-\t\t// Reset it to stateless so that it can be tested again\n-\t\tthis.stateless = null;\n-\n-\t\t// Set form component values from cookies\n-\t\tsetFormComponentValuesFromCookies();\n-\n-\t\t// First, give priority to IFeedback instances, as they have to\n-\t\t// collect their messages before components like ListViews\n-\t\t// remove any child components\n-\t\tvisitChildren(IFeedback.class, new IVisitor()\n-\t\t{\n-\t\t\tpublic Object component(Component component)\n-\t\t\t{\n-\t\t\t\t((IFeedback)component).updateFeedback();\n-\t\t\t\tcomponent.attach();\n-\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n-\t\t\t}\n-\t\t});\n-\n-\t\tif (this instanceof IFeedback)\n-\t\t{\n-\t\t\t((IFeedback)this).updateFeedback();\n-\t\t}\n-\n-\t\t// Now, do the initialization for the other components\n-\t\tattach();\n-\n-\t\t// Visit all this page's children to reset markup streams and check\n-\t\t// rendering authorization, as appropriate. We set any result; positive\n-\t\t// or negative as a temporary boolean in the components, and when a\n-\t\t// authorization exception is thrown it will block the rendering of this\n-\t\t// page\n-\n-\t\t// first the page itself\n-\t\tsetRenderAllowed(isActionAuthorized(RENDER));\n-\t\t// children of the page\n-\t\tvisitChildren(new IVisitor()\n-\t\t{\n-\t\t\tpublic Object component(final Component component)\n-\t\t\t{\n-\t\t\t\t// Find out if this component can be rendered\n-\t\t\t\tfinal boolean renderAllowed = component.isActionAuthorized(RENDER);\n-\n-\t\t\t\t// Authorize rendering\n-\t\t\t\tcomponent.setRenderAllowed(renderAllowed);\n-\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n-\t\t\t}\n-\t\t});\n-\n-\t\t// Handle request by rendering page\n-\t\trender(null);\n-\n-\t\t// Check rendering if it happened fully\n-\t\tcheckRendering(this);\n-\n-\t\tif (!isPageStateless())\n-\t\t{\n-\t\t\t// trigger creation of the actual session in case it was deferred\n-\t\t\tSession.get().getSessionStore().getSessionId(RequestCycle.get().getRequest(), true);\n-\t\t\t// Add/touch the response page in the session (its pagemap).\n-\t\t\tgetSession().touch(this);\n-\t\t}\n-\t}\n-\n \t/**\n \t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n \t * \n@@ -431,6 +375,14 @@ public final void expireOldestVersion()\n \t\t}\n \t}\n \n+\t/**\n+\t * @return The current ajax version number of this page.\n+\t */\n+\tpublic final int getAjaxVersionNumber()\n+\t{\n+\t\treturn versionManager == null ? 0 : versionManager.getAjaxVersionNumber();\n+\t}\n+\n \t/**\n \t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL IT.\n \t * \n@@ -454,42 +406,6 @@ public final int getCurrentVersionNumber()\n \t\treturn versionManager == null ? 0 : versionManager.getCurrentVersionNumber();\n \t}\n \n-\t/**\n-\t * @return The current ajax version number of this page. \n-\t */\n-\tpublic final int getAjaxVersionNumber()\n-\t{\n-\t\treturn versionManager == null ? 0 : versionManager.getAjaxVersionNumber();\n-\t}\n-\t\n-\t/**\n-\t * This returns a page instance that is rollbacked the number of versions\n-\t * that is specified compared to the current page.\n-\t * \n-\t * This is a rollback including ajax versions. \n-\t * \n-\t * @param numberOfVersions to rollback\n-\t * @return\n-\t */\n-\tpublic final Page rollbackPage(int numberOfVersions)\n-\t{\n-\t\tPage page =  versionManager == null? this : versionManager.rollbackPage(numberOfVersions);\n-\t\tgetSession().touch(page);\n-\t\treturn page;\n-\t}\n-\t/**\n-\t * @return Returns feedback messages from all components in this page\n-\t *         (including the page itself).\n-\t */\n-\tpublic final FeedbackMessages getFeedbackMessages()\n-\t{\n-\t\tif (feedbackMessages == null)\n-\t\t{\n-\t\t\tfeedbackMessages = new FeedbackMessages();\n-\t\t}\n-\t\treturn feedbackMessages;\n-\t}\n-\n \t/**\n \t * @see wicket.Component#getId()\n \t */\n@@ -610,7 +526,8 @@ public Page getVersion(final int versionNumber)\n \t\t\t\t}\n \n \t\t\t\t// If we went all the way back to the original page\n-\t\t\t\tif (page != null && page.getCurrentVersionNumber() == 0 && page.getAjaxVersionNumber() == 0)\n+\t\t\t\tif (page != null && page.getCurrentVersionNumber() == 0\n+\t\t\t\t\t\t&& page.getAjaxVersionNumber() == 0)\n \t\t\t\t{\n \t\t\t\t\t// remove version info\n \t\t\t\t\tpage.versionManager = null;\n@@ -658,6 +575,28 @@ public Object component(Component component)\n \t\treturn buffer.toString();\n \t}\n \n+\t/**\n+\t * Call this method when the current (ajax) request shouldn't merge the\n+\t * changes that are happening to the page with the previous version.\n+\t * \n+\t * This is for example needed when you want to redirect to this page in an\n+\t * ajax request and then you do want to version normally..\n+\t * \n+\t * This method doesn't do anything if the getRequest().mergeVersion doesn't\n+\t * return true.\n+\t */\n+\tpublic final void ignoreVersionMerge()\n+\t{\n+\t\tif (getRequest().mergeVersion())\n+\t\t{\n+\t\t\tmayTrackChangesFor(this, null);\n+\t\t\tif (versionManager != null)\n+\t\t\t{\n+\t\t\t\tversionManager.ignoreVersionMerge();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t/**\n \t * Bookmarkable page can be instantiated using a bookmarkable URL.\n \t * \n@@ -713,16 +652,6 @@ public boolean isErrorPage()\n \t\treturn false;\n \t}\n \n-\t/**\n-\t * Set page stateless\n-\t * \n-\t * @param stateless\n-\t */\n-\tvoid setPageStateless(Boolean stateless)\n-\t{\n-\t\tthis.stateless = stateless;\n-\t}\n-\n \t/**\n \t * Gets whether the page is stateless. Components on stateless page must not\n \t * render any statefull urls, and components on statefull page must not\n@@ -827,288 +756,117 @@ public Object component(final Component component)\n \t}\n \n \t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n-\t * \n-\t * Set the id for this Page. This method is called by PageMap when a Page is\n-\t * added because the id, which is assigned by PageMap, is not known until\n-\t * this time.\n-\t * \n-\t * @param id\n-\t *            The id\n-\t */\n-\tpublic final void setNumericId(final int id)\n-\t{\n-\t\tthis.numericId = (short)id;\n-\t}\n-\n-\t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n-\t * \n-\t * This method is called when a component will be rendered standalone.\n-\t * \n-\t * @param component\n-\t * \n-\t */\n-\tpublic final void startComponentRender(Component component)\n-\t{\n-\t\trenderedComponents = null;\n-\t}\n-\n-\t/**\n-\t * Get the string representation of this container.\n-\t * \n-\t * @return String representation of this container\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL IT.\n \t */\n-\tpublic String toString()\n+\tpublic final void renderPage()\n \t{\n-\t\tif(versionManager != null)\n+\t\t// first try to check if the page can be rendered:\n+\t\tif (!isActionAuthorized(RENDER))\n \t\t{\n-\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \n-\t\t\t\t\", version = \" + versionManager.getCurrentVersionNumber()  + \", ajax = \" + \n-\t\t\t\tversionManager.getAjaxVersionNumber() + \"]\";\t\n-\t\t}\n-\t\telse\n+\t\t\tif (log.isDebugEnabled())\n \t\t\t{\n-\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \", version = \" + 0 + \"]\";\n+\t\t\t\tlog.debug(\"Page not allowed to render: \" + this);\n \t\t\t}\n+\t\t\tthrow new UnauthorizedActionException(this, Component.RENDER);\n \t\t}\n \n-\t/**\n-\t * Set-up response with appropriate content type, locale and encoding. The\n-\t * locale is set equal to the session's locale. The content type header\n-\t * contains information about the markup type (@see #getMarkupType()) and\n-\t * the encoding. The response (and request) encoding is determined by an\n-\t * application setting (@see\n-\t * ApplicationSettings#getResponseRequestEncoding()). In addition, if the\n-\t * page's markup contains a xml declaration like &lt?xml ... ?&gt; an xml\n-\t * declaration with proper encoding information is written to the output as\n-\t * well, provided it is not disabled by an applicaton setting (@see\n-\t * ApplicationSettings#getStripXmlDeclarationFromOutput()).\n-\t * <p>\n-\t * Note: Prior to Wicket 1.1 the output encoding was determined by the\n-\t * page's markup encoding. Because this caused uncertainties about the\n-\t * /request/ encoding, it has been changed in favour of the new, much safer,\n-\t * approach. Please see the Wiki for more details.\n-\t */\n-\tprotected void configureResponse()\n-\t{\n-\t\t// Get the response and application\n-\t\tfinal RequestCycle cycle = getRequestCycle();\n-\t\tfinal Application application = cycle.getApplication();\n-\t\tfinal Response response = cycle.getResponse();\n+\t\t// Make sure it is really empty\n+\t\trenderedComponents = null;\n \n-\t\t// Determine encoding\n-\t\tfinal String encoding = application.getRequestCycleSettings().getResponseRequestEncoding();\n+\t\t// Reset it to stateless so that it can be tested again\n+\t\tthis.stateless = null;\n \n-\t\t// Set content type based on markup type for page\n-\t\tresponse.setContentType(\"text/\" + getMarkupType() + \"; charset=\" + encoding);\n+\t\t// Set form component values from cookies\n+\t\tsetFormComponentValuesFromCookies();\n \n-\t\t// Write out an xml declaration if the markup stream and settings allow\n-\t\tfinal MarkupStream markupStream = findMarkupStream();\n-\t\tif ((markupStream != null) && (markupStream.getXmlDeclaration() != null)\n-\t\t\t\t&& (application.getMarkupSettings().getStripXmlDeclarationFromOutput() == false))\n+\t\t// First, give priority to IFeedback instances, as they have to\n+\t\t// collect their messages before components like ListViews\n+\t\t// remove any child components\n+\t\tvisitChildren(IFeedback.class, new IVisitor()\n \t\t{\n-\t\t\tresponse.write(\"<?xml version='1.0' encoding='\");\n-\t\t\tresponse.write(encoding);\n-\t\t\tresponse.write(\"'?>\");\n-\t\t}\n-\n-\t\t// Set response locale from session locale\n-\t\tresponse.setLocale(getSession().getLocale());\n+\t\t\tpublic Object component(Component component)\n+\t\t\t{\n+\t\t\t\t((IFeedback)component).updateFeedback();\n+\t\t\t\tcomponent.attach();\n+\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n \t\t\t}\n+\t\t});\n \n-\t/**\n-\t * @see wicket.Component#onDetach()\n-\t */\n-\tprotected void onDetach()\n-\t{\n-\t\tif (log.isDebugEnabled())\n+\t\tif (this instanceof IFeedback)\n \t\t{\n-\t\t\tlog.debug(\"ending request for page \" + this + \", request \" + getRequest());\n+\t\t\t((IFeedback)this).updateFeedback();\n \t\t}\n \n-\t\tendVersion();\n+\t\t// Now, do the initialization for the other components\n+\t\tattach();\n \n-\t\tsuper.onDetach();\n-\t}\n+\t\t// Visit all this page's children to reset markup streams and check\n+\t\t// rendering authorization, as appropriate. We set any result; positive\n+\t\t// or negative as a temporary boolean in the components, and when a\n+\t\t// authorization exception is thrown it will block the rendering of this\n+\t\t// page\n \n-\t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n-\t * OVERRIDE.\n-\t * \n-\t * @see wicket.Component#internalOnModelChanged()\n-\t */\n-\tprotected final void internalOnModelChanged()\n-\t{\n-\t\tvisitChildren(new Component.IVisitor()\n+\t\t// first the page itself\n+\t\tsetRenderAllowed(isActionAuthorized(RENDER));\n+\t\t// children of the page\n+\t\tvisitChildren(new IVisitor()\n \t\t{\n \t\t\tpublic Object component(final Component component)\n \t\t\t{\n-\t\t\t\t// If form component is using form model\n-\t\t\t\tif (component.sameRootModel(Page.this))\n-\t\t\t\t{\n-\t\t\t\t\tcomponent.modelChanged();\n-\t\t\t\t}\n+\t\t\t\t// Find out if this component can be rendered\n+\t\t\t\tfinal boolean renderAllowed = component.isActionAuthorized(RENDER);\n+\n+\t\t\t\t// Authorize rendering\n+\t\t\t\tcomponent.setRenderAllowed(renderAllowed);\n \t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n \t\t\t}\n \t\t});\n-\t}\n \n-\t/**\n-\t * @return Factory method that creates a version manager for this Page\n-\t */\n-\tprotected final IPageVersionManager newVersionManager()\n-\t{\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Renders this container to the given response object.\n-\t * \n-\t * @param markupStream\n-\t */\n-\tprotected void onRender(final MarkupStream markupStream)\n-\t{\n-\t\t// Set page's associated markup stream\n-\t\tfinal MarkupStream associatedMarkupStream = getAssociatedMarkupStream(true);\n-\t\tsetMarkupStream(associatedMarkupStream);\n-\n-\t\t// Configure response object with locale and content type\n-\t\tconfigureResponse();\n-\n-\t\t// Render all the page's markup\n-\t\tsetFlag(FLAG_IS_RENDERING, true);\n-\t\ttry\n-\t\t{\n-\t\t\trenderAll(associatedMarkupStream);\n-\t\t}\n-\t\tfinally\n-\t\t{\n-\t\t\tsetFlag(FLAG_IS_RENDERING, false);\n-\t\t}\n-\t}\n+\t\t// Handle request by rendering page\n+\t\trender(null);\n \n-\t/**\n-\t * A component was added.\n-\t * \n-\t * @param component\n-\t *            The component that was added\n-\t */\n-\tfinal void componentAdded(final Component component)\n-\t{\n-\t\tcheckHierarchyChange(component);\n+\t\t// Check rendering if it happened fully\n+\t\tcheckRendering(this);\n \n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\t\tif (!isPageStateless())\n \t\t{\n-\t\t\tversionManager.componentAdded(component);\n+\t\t\t// trigger creation of the actual session in case it was deferred\n+\t\t\tSession.get().getSessionStore().getSessionId(RequestCycle.get().getRequest(), true);\n+\t\t\t// Add/touch the response page in the session (its pagemap).\n+\t\t\tgetSession().touch(this);\n \t\t}\n \t}\n \n \t/**\n-\t * A component's model changed.\n+\t * This returns a page instance that is rollbacked the number of versions\n+\t * that is specified compared to the current page.\n \t * \n-\t * @param component\n-\t *            The component whose model is about to change\n-\t */\n-\tfinal void componentModelChanging(final Component component)\n-\t{\n-\t\tcheckHierarchyChange(component);\n-\n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, null))\n-\t\t{\n-\t\t\tversionManager.componentModelChanging(component);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * A component was removed.\n+\t * This is a rollback including ajax versions.\n \t * \n-\t * @param component\n-\t *            The component that was removed\n+\t * @param numberOfVersions\n+\t *            to rollback\n+\t * @return\n \t */\n-\tfinal void componentRemoved(final Component component)\n-\t{\n-\t\tcheckHierarchyChange(component);\n-\n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\tpublic final Page rollbackPage(int numberOfVersions)\n \t{\n-\t\t\tversionManager.componentRemoved(component);\n-\t\t}\n+\t\tPage page = versionManager == null ? this : versionManager.rollbackPage(numberOfVersions);\n+\t\tgetSession().touch(page);\n+\t\treturn page;\n \t}\n \n \t/**\n-\t * Adds a component to the set of rendered components.\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n \t * \n-\t * @param component\n-\t *            The component that was rendered\n-\t */\n-\tpublic final void componentRendered(final Component component)\n-\t{\n-\t\t// Inform the page that this component rendered\n-\t\tif (Application.get().getDebugSettings().getComponentUseCheck())\n-\t\t{\n-\t\t\tif (renderedComponents == null)\n-\t\t\t{\n-\t\t\t\trenderedComponents = new HashSet();\n-\t\t\t}\n-\t\t\tif (renderedComponents.add(component) == false)\n-\t\t\t{\n-\t\t\t\tthrow new MarkupException(\n-\t\t\t\t\t\t\"The component \"\n-\t\t\t\t\t\t\t\t+ component\n-\t\t\t\t\t\t\t\t+ \" has the same wicket:id as another component already added at the same level\");\n-\t\t\t}\n-\t\t\tif (log.isDebugEnabled())\n-\t\t\t{\n-\t\t\t\tlog.debug(\"Rendered \" + component);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tfinal void componentStateChanging(final Component component, Change change)\n-\t{\n-\t\tcheckHierarchyChange(component);\n-\n-\t\tdirty();\n-\t\tif (mayTrackChangesFor(component, null))\n-\t\t{\n-\t\t\tversionManager.componentStateChanging(change);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Sets values for form components based on cookie values in the request.\n+\t * Set the id for this Page. This method is called by PageMap when a Page is\n+\t * added because the id, which is assigned by PageMap, is not known until\n+\t * this time.\n \t * \n+\t * @param id\n+\t *            The id\n \t */\n-\tfinal void setFormComponentValuesFromCookies()\n-\t{\n-\t\t// Visit all Forms contained in the page\n-\t\tvisitChildren(Form.class, new Component.IVisitor()\n-\t\t{\n-\t\t\t// For each FormComponent found on the Page (not Form)\n-\t\t\tpublic Object component(final Component component)\n-\t\t\t{\n-\t\t\t\t((Form)component).loadPersistentFormComponentValues();\n-\t\t\t\treturn CONTINUE_TRAVERSAL;\n-\t\t\t}\n-\t\t});\n-\t}\n-\n-\t/**\n-\t * @param pageMap\n-\t *            Sets this page into the page map with the given name. If the\n-\t *            page map does not yet exist, it is automatically created.\n-\t */\n-\tfinal void setPageMap(final IPageMap pageMap)\n+\tpublic final void setNumericId(final int id)\n \t{\n-\t\t// Save transient reference to pagemap\n-\t\tthis.pageMap = pageMap;\n-\n-\t\t// Save name for restoring transient\n-\t\tthis.pageMapName = pageMap.getName();\n+\t\tthis.numericId = (short)id;\n \t}\n \n \t/**\n@@ -1131,21 +889,37 @@ public final void setStatelessHint(boolean value)\n \t}\n \n \t/**\n-\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n-\t * OVERRIDE.\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL.\n+\t * \n+\t * This method is called when a component will be rendered standalone.\n+\t * \n+\t * @param component\n \t * \n-\t * @param map\n \t */\n-\tprotected final void moveToPageMap(IPageMap map)\n+\tpublic final void startComponentRender(Component component)\n \t{\n-\t\t// TODO post 1.2 shouldn't we remove this page from the pagemap/session\n-\t\t// if it would be in there?\n-\t\t// This should be done if the page was not cloned first, but shouldn't\n-\t\t// be done if it was cloned..\n-\t\tsetPageMap(map);\n-\t\tnumericId = (short)map.nextId();\n+\t\trenderedComponents = null;\n \t}\n \n+\t/**\n+\t * Get the string representation of this container.\n+\t * \n+\t * @return String representation of this container\n+\t */\n+\tpublic String toString()\n+\t{\n+\t\tif (versionManager != null)\n+\t\t{\n+\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \", version = \"\n+\t\t\t\t\t+ versionManager.getCurrentVersionNumber() + \", ajax = \"\n+\t\t\t\t\t+ versionManager.getAjaxVersionNumber() + \"]\";\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\treturn \"[Page class = \" + getClass().getName() + \", id = \" + getId() + \", version = \"\n+\t\t\t\t\t+ 0 + \"]\";\n+\t\t}\n+\t}\n \n \t/**\n \t * Checks whether the hierarchy may be changed at all, and throws an\n@@ -1362,24 +1136,238 @@ private final boolean mayTrackChangesFor(final Component component, MarkupContai\n \t}\n \n \t/**\n-\t * Call this method when the current (ajax) request shouldn't merge \n-\t * the changes that are happening to the page with the previous version. \n+\t * Set-up response with appropriate content type, locale and encoding. The\n+\t * locale is set equal to the session's locale. The content type header\n+\t * contains information about the markup type (@see #getMarkupType()) and\n+\t * the encoding. The response (and request) encoding is determined by an\n+\t * application setting (@see\n+\t * ApplicationSettings#getResponseRequestEncoding()). In addition, if the\n+\t * page's markup contains a xml declaration like &lt?xml ... ?&gt; an xml\n+\t * declaration with proper encoding information is written to the output as\n+\t * well, provided it is not disabled by an applicaton setting (@see\n+\t * ApplicationSettings#getStripXmlDeclarationFromOutput()).\n+\t * <p>\n+\t * Note: Prior to Wicket 1.1 the output encoding was determined by the\n+\t * page's markup encoding. Because this caused uncertainties about the\n+\t * /request/ encoding, it has been changed in favour of the new, much safer,\n+\t * approach. Please see the Wiki for more details.\n+\t */\n+\tprotected void configureResponse()\n+\t{\n+\t\t// Get the response and application\n+\t\tfinal RequestCycle cycle = getRequestCycle();\n+\t\tfinal Application application = cycle.getApplication();\n+\t\tfinal Response response = cycle.getResponse();\n+\n+\t\t// Determine encoding\n+\t\tfinal String encoding = application.getRequestCycleSettings().getResponseRequestEncoding();\n+\n+\t\t// Set content type based on markup type for page\n+\t\tresponse.setContentType(\"text/\" + getMarkupType() + \"; charset=\" + encoding);\n+\n+\t\t// Write out an xml declaration if the markup stream and settings allow\n+\t\tfinal MarkupStream markupStream = findMarkupStream();\n+\t\tif ((markupStream != null) && (markupStream.getXmlDeclaration() != null)\n+\t\t\t\t&& (application.getMarkupSettings().getStripXmlDeclarationFromOutput() == false))\n+\t\t{\n+\t\t\tresponse.write(\"<?xml version='1.0' encoding='\");\n+\t\t\tresponse.write(encoding);\n+\t\t\tresponse.write(\"'?>\");\n+\t\t}\n+\n+\t\t// Set response locale from session locale\n+\t\tresponse.setLocale(getSession().getLocale());\n+\t}\n+\n+\t/**\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n+\t * OVERRIDE.\n+\t * \n+\t * @see wicket.Component#internalOnModelChanged()\n+\t */\n+\tprotected final void internalOnModelChanged()\n+\t{\n+\t\tvisitChildren(new Component.IVisitor()\n+\t\t{\n+\t\t\tpublic Object component(final Component component)\n+\t\t\t{\n+\t\t\t\t// If form component is using form model\n+\t\t\t\tif (component.sameRootModel(Page.this))\n+\t\t\t\t{\n+\t\t\t\t\tcomponent.modelChanged();\n+\t\t\t\t}\n+\t\t\t\treturn IVisitor.CONTINUE_TRAVERSAL;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT CALL OR\n+\t * OVERRIDE.\n \t * \n-\t * This is for example needed when you want to redirect to this \n-\t * page in an ajax request and then you do want to version normally.. \n+\t * @param map\n+\t */\n+\tprotected final void moveToPageMap(IPageMap map)\n+\t{\n+\t\t// TODO post 1.2 shouldn't we remove this page from the pagemap/session\n+\t\t// if it would be in there?\n+\t\t// This should be done if the page was not cloned first, but shouldn't\n+\t\t// be done if it was cloned..\n+\t\tsetPageMap(map);\n+\t\tnumericId = (short)map.nextId();\n+\t}\n+\n+\t/**\n+\t * @return Factory method that creates a version manager for this Page\n+\t */\n+\tprotected final IPageVersionManager newVersionManager()\n+\t{\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * @see wicket.Component#onDetach()\n+\t */\n+\tprotected void onDetach()\n+\t{\n+\t\tif (log.isDebugEnabled())\n+\t\t{\n+\t\t\tlog.debug(\"ending request for page \" + this + \", request \" + getRequest());\n+\t\t}\n+\n+\t\tendVersion();\n+\n+\t\tsuper.onDetach();\n+\t}\n+\n+\t/**\n+\t * Renders this container to the given response object.\n \t * \n-\t * This method doesn't do anything if the getRequest().mergeVersion\n-\t * doesn't return true.\n+\t * @param markupStream\n \t */\n-\tpublic final void ignoreVersionMerge()\n+\tprotected void onRender(final MarkupStream markupStream)\n \t{\n-\t\tif (getRequest().mergeVersion())\n+\t\t// Set page's associated markup stream\n+\t\tfinal MarkupStream associatedMarkupStream = getAssociatedMarkupStream(true);\n+\t\tsetMarkupStream(associatedMarkupStream);\n+\n+\t\t// Configure response object with locale and content type\n+\t\tconfigureResponse();\n+\n+\t\t// Render all the page's markup\n+\t\tsetFlag(FLAG_IS_RENDERING, true);\n+\t\ttry\n \t\t{\n-\t\t\tmayTrackChangesFor(this, null);\n-\t\t\tif (versionManager != null)\n+\t\t\trenderAll(associatedMarkupStream);\n+\t\t}\n+\t\tfinally\n \t\t{\n-\t\t\t\tversionManager.ignoreVersionMerge();\n+\t\t\tsetFlag(FLAG_IS_RENDERING, false);\n \t\t}\n \t}\n+\n+\n+\t/**\n+\t * A component was added.\n+\t * \n+\t * @param component\n+\t *            The component that was added\n+\t */\n+\tfinal void componentAdded(final Component component)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\t\t{\n+\t\t\tversionManager.componentAdded(component);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A component's model changed.\n+\t * \n+\t * @param component\n+\t *            The component whose model is about to change\n+\t */\n+\tfinal void componentModelChanging(final Component component)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, null))\n+\t\t{\n+\t\t\tversionManager.componentModelChanging(component);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A component was removed.\n+\t * \n+\t * @param component\n+\t *            The component that was removed\n+\t */\n+\tfinal void componentRemoved(final Component component)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, component.getParent()))\n+\t\t{\n+\t\t\tversionManager.componentRemoved(component);\n+\t\t}\n+\t}\n+\n+\tfinal void componentStateChanging(final Component component, Change change)\n+\t{\n+\t\tcheckHierarchyChange(component);\n+\n+\t\tdirty();\n+\t\tif (mayTrackChangesFor(component, null))\n+\t\t{\n+\t\t\tversionManager.componentStateChanging(change);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets values for form components based on cookie values in the request.\n+\t * \n+\t */\n+\tfinal void setFormComponentValuesFromCookies()\n+\t{\n+\t\t// Visit all Forms contained in the page\n+\t\tvisitChildren(Form.class, new Component.IVisitor()\n+\t\t{\n+\t\t\t// For each FormComponent found on the Page (not Form)\n+\t\t\tpublic Object component(final Component component)\n+\t\t\t{\n+\t\t\t\t((Form)component).loadPersistentFormComponentValues();\n+\t\t\t\treturn CONTINUE_TRAVERSAL;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t/**\n+\t * @param pageMap\n+\t *            Sets this page into the page map with the given name. If the\n+\t *            page map does not yet exist, it is automatically created.\n+\t */\n+\tfinal void setPageMap(final IPageMap pageMap)\n+\t{\n+\t\t// Save transient reference to pagemap\n+\t\tthis.pageMap = pageMap;\n+\n+\t\t// Save name for restoring transient\n+\t\tthis.pageMapName = pageMap.getName();\n+\t}\n+\n+\t/**\n+\t * Set page stateless\n+\t * \n+\t * @param stateless\n+\t */\n+\tvoid setPageStateless(Boolean stateless)\n+\t{\n+\t\tthis.stateless = stateless;\n \t}\n }\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java b/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java\nindex 9db2282ea3..b8e00a5dd4 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/RequestCycle.java\n@@ -886,7 +886,7 @@ private void detach()\n \t\t// remove any rendered feedback messages from the session\n \t\ttry\n \t\t{\n-\t\t\tsession.cleanupFeedbackMessages();\n+\t\t\tsession.cleanupRenderedFeedbackMessages();\n \t\t}\n \t\tcatch (RuntimeException re)\n \t\t{\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/Session.java b/jdk-1.4/wicket/src/main/java/wicket/Session.java\nindex ae82d317c2..0e88aeda05 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/Session.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/Session.java\n@@ -37,7 +37,6 @@\n import wicket.feedback.FeedbackMessages;\n import wicket.request.ClientInfo;\n import wicket.session.ISessionStore;\n-import wicket.util.concurrent.CopyOnWriteArrayList;\n import wicket.util.convert.IConverter;\n import wicket.util.lang.Objects;\n import wicket.util.string.Strings;\n@@ -199,7 +198,7 @@ public boolean add(IPageMap pagemap)\n \tprivate String style;\n \n \t/** feedback messages */\n-\tprivate FeedbackMessages feedbackMessages = new FeedbackMessages(new CopyOnWriteArrayList());\n+\tprivate FeedbackMessages feedbackMessages = new FeedbackMessages();\n \n \tprivate transient Map pageMapsUsedInRequest;\n \n@@ -1133,7 +1132,7 @@ else if (object instanceof IPageMap)\n \t * Removes any rendered feedback messages as well as compacts memory. This\n \t * method is usually called at the end of the request cycle processing.\n \t */\n-\tfinal void cleanupFeedbackMessages()\n+\tfinal void cleanupRenderedFeedbackMessages()\n \t{\n \t\tint size = feedbackMessages.size();\n \t\tfeedbackMessages.clearRendered();\n@@ -1145,6 +1144,26 @@ final void cleanupFeedbackMessages()\n \t\t}\n \t}\n \n+\t/**\n+\t * Cleans up any unrendered, dangling feedback messages there may be. This\n+\t * implementation calls {@link FeedbackMessages#clearComponentSpecific()} to\n+\t * aggresively ensure there won't be memory leaks. Clients can override this\n+\t * method to e.g. call {@link FeedbackMessages#clearPageSpecific(Page)}.\n+\t * <p>\n+\t * This method should be called from by the framework right before a even\n+\t * handler is called. There is no need for clients to call this method\n+\t * directly\n+\t * </p>\n+\t * \n+\t * @param page\n+\t *            any current page (the page on which the event handler is that\n+\t *            is about to be processed)\n+\t */\n+\tpublic void cleanupFeedbackMessages(Page page)\n+\t{\n+\t\tfeedbackMessages.clearComponentSpecific();\n+\t}\n+\n \t/**\n \t * @param page\n \t *            The page to add to dirty objects list\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java\nindex 7da26624b4..719e1773e0 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessages.java\n@@ -27,6 +27,7 @@\n \n import wicket.Component;\n import wicket.IClusterable;\n+import wicket.Page;\n import wicket.util.concurrent.CopyOnWriteArrayList;\n import wicket.util.string.StringList;\n \n@@ -58,24 +59,37 @@\n \t */\n \tpublic FeedbackMessages()\n \t{\n-\t\tmessages = new ArrayList();\n+\t\tmessages = new CopyOnWriteArrayList();\n \t}\n \n \t/**\n-\t * Call this constructor if you want to replace the internal\n-\t * store with another implemention then the default (ArrayList). \n-\t * This could be a {@link CopyOnWriteArrayList} if this feedbackmessages \n-\t * instance is used by multiply threads.\n+\t * Call this constructor if you want to replace the internal store with\n+\t * another implemention then the default (ArrayList). This could be a\n+\t * {@link CopyOnWriteArrayList} if this feedbackmessages instance is used by\n+\t * multiply threads.\n \t * \n \t * @param messagesList\n \t * \n \t */\n \tpublic FeedbackMessages(List messagesList)\n \t{\n-\t\tif(messagesList == null) throw new IllegalArgumentException(\"messages list can't be null\");\n+\t\tif (messagesList == null)\n+\t\t\tthrow new IllegalArgumentException(\"messages list can't be null\");\n \t\tmessages = messagesList;\n \t}\n \n+\t/**\n+\t * Adds a message\n+\t * \n+\t * @param reporter\n+\t * @param message\n+\t * @param level\n+\t */\n+\tpublic final void add(Component reporter, String message, int level)\n+\t{\n+\t\tadd(new FeedbackMessage(reporter, message, level));\n+\t}\n+\n \t/**\n \t * Clears any existing messages\n \t */\n@@ -85,13 +99,50 @@ public final void clear()\n \t}\n \n \t/**\n-\t * Gets the number of messages\n+\t * Clears any messages specifically for components. This is an aggressive\n+\t * cleanup to ensure there won't be a memory leak in session.\n+\t */\n+\tpublic final void clearComponentSpecific()\n+\t{\n+\t\tfor (int i = messages.size() - 1; i >= 0; i--)\n+\t\t{\n+\t\t\tfinal FeedbackMessage msg = (FeedbackMessage)messages.get(i);\n+\t\t\tComponent reporter = msg.getReporter();\n+\t\t\tif (reporter != null)\n+\t\t\t{\n+\t\t\t\tmessages.remove(i);\n+\t\t\t}\n+\t\t}\n+\t\ttrimToSize();\n+\t}\n+\n+\t/**\n+\t * Clears any messages specifically for components on the provided page.\n \t * \n-\t * @return the number of messages\n+\t * @param page\n+\t *            The page to clear messages for\n \t */\n-\tpublic final int size()\n+\tpublic final void clearPageSpecific(Page page)\n \t{\n-\t\treturn messages.size();\n+\t\tif (page == null)\n+\t\t{\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfor (int i = messages.size() - 1; i >= 0; i--)\n+\t\t{\n+\t\t\tfinal FeedbackMessage msg = (FeedbackMessage)messages.get(i);\n+\t\t\tComponent reporter = msg.getReporter();\n+\t\t\tif (reporter != null)\n+\t\t\t{\n+\t\t\t\tPage reporterPage = (Page)reporter.findParent(Page.class);\n+\t\t\t\tif (reporterPage != null && reporterPage.equals(page))\n+\t\t\t\t{\n+\t\t\t\t\tmessages.remove(i);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\ttrimToSize();\n \t}\n \n \t/**\n@@ -225,6 +276,16 @@ public final boolean isEmpty()\n \t\treturn messages.isEmpty();\n \t}\n \n+\t/**\n+\t * Gets an iterator over stored messages\n+\t * \n+\t * @return iterator over stored messages\n+\t */\n+\tpublic final Iterator iterator()\n+\t{\n+\t\treturn messages.iterator();\n+\t}\n+\n \t/**\n \t * Looks up a message for the given component.\n \t * \n@@ -274,6 +335,16 @@ public final List messages(final IFeedbackMessageFilter filter)\n \t\t}\n \t}\n \n+\t/**\n+\t * Gets the number of messages\n+\t * \n+\t * @return the number of messages\n+\t */\n+\tpublic final int size()\n+\t{\n+\t\treturn messages.size();\n+\t}\n+\n \t/**\n \t * @see java.lang.Object#toString()\n \t */\n@@ -282,6 +353,17 @@ public String toString()\n \t\treturn \"[feedbackMessages = \" + StringList.valueOf(messages) + \"]\";\n \t}\n \n+\t/**\n+\t * Frees any unnecessary internal storage\n+\t */\n+\tpublic final void trimToSize()\n+\t{\n+\t\tif (messages instanceof ArrayList)\n+\t\t{\n+\t\t\t((ArrayList)messages).trimToSize();\n+\t\t}\n+\t}\n+\n \t/**\n \t * Adds a new ui message with level WARNING to the current messages.\n \t * \n@@ -295,16 +377,6 @@ public final void warn(Component reporter, String message)\n \t\tadd(new FeedbackMessage(reporter, message, FeedbackMessage.WARNING));\n \t}\n \n-\t/**\n-\t * Adds a message\n-\t * @param reporter\n-\t * @param message\n-\t * @param level\n-\t */\n-\tpublic final void add(Component reporter, String message, int level) {\n-\t\tadd(new FeedbackMessage(reporter, message, level));\n-\t}\n-\t\n \t/**\n \t * Adds a message.\n \t * \n@@ -319,25 +391,4 @@ final void add(FeedbackMessage message)\n \t\t}\n \t\tmessages.add(message);\n \t}\n-\n-\t/**\n-\t * Gets an iterator over stored messages\n-\t * \n-\t * @return iterator over stored messages\n-\t */\n-\tpublic final Iterator iterator()\n-\t{\n-\t\treturn messages.iterator();\n-\t}\n-\n-\t/**\n-\t * Frees any unnecessary internal storage\n-\t */\n-\tpublic final void trimToSize()\n-\t{\n-\t\tif(messages instanceof ArrayList)\n-\t\t{\n-\t\t\t((ArrayList)messages).trimToSize();\n-\t\t}\n-\t}\n }\n\\ No newline at end of file\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java\nindex 7b5230021d..82f39b27c9 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/feedback/FeedbackMessagesModel.java\n@@ -17,13 +17,13 @@\n package wicket.feedback;\n \n import java.io.Serializable;\n-import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.List;\n \n import wicket.Component;\n import wicket.Page;\n+import wicket.Session;\n import wicket.model.IModel;\n \n /**\n@@ -51,8 +51,9 @@\n \t * Constructor. Creates a model for all feedback messages on the page.\n \t * \n \t * @param component\n-\t *            The component where the page will be get from for which messages will be displayed \n-\t *            usually the same page as the one feedbackpanel is attached to\n+\t *            The component where the page will be get from for which\n+\t *            messages will be displayed usually the same page as the one\n+\t *            feedbackpanel is attached to\n \t */\n \tpublic FeedbackMessagesModel(Component component)\n \t{\n@@ -104,13 +105,7 @@ public final Object getObject()\n \t\tif (messages == null)\n \t\t{\n \t\t\t// Get filtered messages from page where component lives\n-\t\t\tList pageMessages = component.getPage().getFeedbackMessages().messages(filter);\n-\n-\t\t\tList sessionMessages = component.getSession().getFeedbackMessages().messages(filter);\n-\n-\t\t\tmessages = new ArrayList(pageMessages.size() + sessionMessages.size());\n-\t\t\tmessages.addAll(pageMessages);\n-\t\t\tmessages.addAll(sessionMessages);\n+\t\t\tmessages = Session.get().getFeedbackMessages().messages(filter);\n \n \t\t\t// Sort the list before returning it\n \t\t\tif (sortingComparator != null)\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java\nindex 2198c9e197..5d4f34a3e9 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackBorder.java\n@@ -16,6 +16,7 @@\n  */\n package wicket.markup.html.form.validation;\n \n+import wicket.Session;\n import wicket.feedback.ContainerFeedbackMessageFilter;\n import wicket.feedback.IFeedback;\n import wicket.feedback.IFeedbackMessageFilter;\n@@ -87,7 +88,7 @@ public FormComponentFeedbackBorder(final String id)\n \tpublic void updateFeedback()\n \t{\n \t\t// Get the messages for the current page\n-\t\tvisible = getPage().getFeedbackMessages().messages(getMessagesFilter()).size() != 0;\n+\t\tvisible = Session.get().getFeedbackMessages().messages(getMessagesFilter()).size() != 0;\n \t}\n \n \t/**\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java\nindex 06531811d2..bb76fee177 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/markup/html/form/validation/FormComponentFeedbackIndicator.java\n@@ -17,6 +17,7 @@\n package wicket.markup.html.form.validation;\n \n import wicket.Component;\n+import wicket.Session;\n import wicket.feedback.ComponentFeedbackMessageFilter;\n import wicket.feedback.IFeedback;\n import wicket.feedback.IFeedbackMessageFilter;\n@@ -74,7 +75,7 @@ public void setIndicatorFor(final Component component)\n \tpublic void updateFeedback()\n \t{\n \t\t// Get the messages for the current page\n-\t\tsetVisible(getPage().getFeedbackMessages().hasMessage(getFeedbackMessageFilter()));\n+\t\tsetVisible(Session.get().getFeedbackMessages().hasMessage(getFeedbackMessageFilter()));\n \t}\n \n \t/**\ndiff --git a/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java b/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java\nindex 7d8fb92767..ed88751140 100644\n--- a/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java\n+++ b/jdk-1.4/wicket/src/main/java/wicket/request/target/component/listener/AbstractListenerInterfaceRequestTarget.java\n@@ -21,6 +21,7 @@\n import wicket.Page;\n import wicket.RequestCycle;\n import wicket.RequestListenerInterface;\n+import wicket.Session;\n import wicket.request.RequestParameters;\n import wicket.request.target.IEventProcessor;\n import wicket.request.target.component.PageRequestTarget;\n@@ -189,7 +190,7 @@ protected void onProcessEvents(final RequestCycle requestCycle)\n \t\trequestCycle.setUpdateSession(true);\n \n \t\t// Clear all feedback messages if it isn't a redirect\n-\t\tgetPage().getFeedbackMessages().clear();\n+\t\tSession.get().cleanupFeedbackMessages(getPage());\n \n \t\tgetPage().startComponentRender(getTarget());\n \n", 
  "project": "wicket", 
  "linesAdd": 522, 
  "jira_id": "442", 
  "nb_skipped": 0, 
  "commit": "246d53c5", 
  "nb_failure": 3, 
  "linesRem": 466
}