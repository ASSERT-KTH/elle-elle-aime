{
  "files": 1, 
  "nb_test": 601, 
  "nb_error": 2, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.accumulo.core.data.ValueTest"
  ], 
  "patch": "diff --git a/core/src/main/java/org/apache/accumulo/core/data/Value.java b/core/src/main/java/org/apache/accumulo/core/data/Value.java\nindex 39ebbd0b2..11e60e159 100644\n--- a/core/src/main/java/org/apache/accumulo/core/data/Value.java\n+++ b/core/src/main/java/org/apache/accumulo/core/data/Value.java\n@@ -25,6 +25,8 @@\n import java.nio.ByteBuffer;\n import java.util.List;\n \n+import com.google.common.base.Preconditions;\n+\n import org.apache.accumulo.core.Constants;\n import org.apache.hadoop.io.BytesWritable;\n import org.apache.hadoop.io.WritableComparable;\n@@ -36,39 +38,52 @@\n  * 'immutable'.\n  */\n public class Value implements WritableComparable<Object> {\n+  private static final byte[] EMPTY = new byte[0];\n   protected byte[] value;\n \n   /**\n    * Create a zero-size sequence.\n    */\n   public Value() {\n-    super();\n+    this(EMPTY, false);\n   }\n   \n   /**\n    * Create a Value using the byte array as the initial value.\n    * \n-   * @param bytes\n-   *          This array becomes the backing storage for the object.\n+   * @param bytes May not be null\n    */\n-  \n   public Value(byte[] bytes) {\n     this(bytes, false);\n   }\n   \n+  /**\n+   * Create a Value using a copy of the ByteBuffer's content.\n+   * \n+   * @param bytes May not be null\n+   */\n   public Value(ByteBuffer bytes) {\n+    /* TODO ACCUMULO-2509 right now this uses the entire backing array, which must be accessible. */\n     this(toBytes(bytes), false);\n   }\n   \n   /**\n+   * @param bytes may not be null\n    * @deprecated A copy of the bytes in the buffer is always made. Use {@link #Value(ByteBuffer)} instead.\n    */\n   @Deprecated\n   public Value(ByteBuffer bytes, boolean copy) {\n+    /* TODO ACCUMULO-2509 right now this uses the entire backing array, which must be accessible. */\n     this(toBytes(bytes), false);\n   }\n   \n+  /**\n+   * Create a Value based on the given bytes.\n+   * @param bytes may not be null\n+   * @param copy signal if Value must make its own copy of bytes, or if it can use the array directly.\n+   */\n   public Value(byte[] bytes, boolean copy) {\n+    Preconditions.checkNotNull(bytes);\n     if (!copy) {\n       this.value = bytes;\n     } else {\n@@ -81,8 +96,7 @@ public Value(byte[] bytes, boolean copy) {\n   /**\n    * Set the new Value to a copy of the contents of the passed <code>ibw</code>.\n    * \n-   * @param ibw\n-   *          the value to set this Value to.\n+   * @param ibw may not be null.\n    */\n   public Value(final Value ibw) {\n     this(ibw.get(), 0, ibw.getSize());\n@@ -91,55 +105,49 @@ public Value(final Value ibw) {\n   /**\n    * Set the value to a copy of the given byte range\n    * \n-   * @param newData\n-   *          the new values to copy in\n+   * @param newData source of copy, may not be null\n    * @param offset\n    *          the offset in newData to start at\n    * @param length\n    *          the number of bytes to copy\n    */\n   public Value(final byte[] newData, final int offset, final int length) {\n+    Preconditions.checkNotNull(newData);\n     this.value = new byte[length];\n     System.arraycopy(newData, offset, this.value, 0, length);\n   }\n   \n   /**\n-   * Get the data from the BytesWritable.\n-   * \n-   * @return The data is only valid between 0 and getSize() - 1.\n+   * @return the underlying byte array directly.\n    */\n   public byte[] get() {\n-    if (this.value == null) {\n-      throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n-    }\n+    assert(null != value);\n     return this.value;\n   }\n   \n   /**\n-   * @param b\n-   *          Use passed bytes as backing array for this instance.\n+   * @param b Use passed bytes as backing array for this instance, may not be null.\n    */\n   public void set(final byte[] b) {\n+    Preconditions.checkNotNull(b);\n     this.value = b;\n   }\n   \n   /**\n    * \n-   * @param b\n-   *          copy bytes\n+   * @param b copy the given byte array, may not be null.\n    */\n   public void copy(byte[] b) {\n+    Preconditions.checkNotNull(b);\n     this.value = new byte[b.length];\n     System.arraycopy(b, 0, this.value, 0, b.length);\n   }\n   \n   /**\n-   * @return the current size of the buffer.\n+   * @return the current size of the underlying buffer.\n    */\n   public int getSize() {\n-    if (this.value == null) {\n-      throw new IllegalStateException(\"Uninitialized. Null constructor \" + \"called w/o accompanying readFields invocation\");\n-    }\n+    assert(null != value);\n     return this.value.length;\n   }\n   \n", 
  "project": "accumulo", 
  "linesAdd": 30, 
  "jira_id": "2487", 
  "nb_skipped": 1, 
  "commit": "f2920c26", 
  "nb_failure": 3, 
  "linesRem": 22
}