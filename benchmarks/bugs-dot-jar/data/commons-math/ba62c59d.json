{
  "files": 1, 
  "nb_test": 5966, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.commons.math3.util.PrecisionTest"
  ], 
  "patch": "diff --git a/src/main/java/org/apache/commons/math3/util/Precision.java b/src/main/java/org/apache/commons/math3/util/Precision.java\nindex d08947617..fa938c008 100644\n--- a/src/main/java/org/apache/commons/math3/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math3/util/Precision.java\n@@ -62,6 +62,14 @@\n     private static final int SGN_MASK_FLOAT = 0x80000000;\n     /** Positive zero. */\n     private static final double POSITIVE_ZERO = 0d;\n+    /** Positive zero bits. */\n+    private static final long POSITIVE_ZERO_DOUBLE_BITS = Double.doubleToRawLongBits(+0.0);\n+    /** Negative zero bits. */\n+    private static final long NEGATIVE_ZERO_DOUBLE_BITS = Double.doubleToRawLongBits(-0.0);\n+    /** Positive zero bits. */\n+    private static final int POSITIVE_ZERO_FLOAT_BITS   = Float.floatToRawIntBits(+0.0f);\n+    /** Negative zero bits. */\n+    private static final int NEGATIVE_ZERO_FLOAT_BITS   = Float.floatToRawIntBits(-0.0f);\n \n     static {\n         /*\n@@ -109,7 +117,7 @@ public static int compareTo(double x, double y, double eps) {\n      * (or fewer) floating point numbers between them, i.e. two adjacent floating\n      * point numbers are considered equal.\n      * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n      * Bruce Dawson</a>\n      *\n      * @param x first value\n@@ -190,7 +198,7 @@ public static boolean equalsIncludingNaN(float x, float y, float eps) {\n      * (or fewer) floating point numbers between them, i.e. two adjacent floating\n      * point numbers are considered equal.\n      * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n      * Bruce Dawson</a>\n      *\n      * @param x first value\n@@ -201,21 +209,37 @@ public static boolean equalsIncludingNaN(float x, float y, float eps) {\n      * point values between {@code x} and {@code y}.\n      * @since 2.2\n      */\n-    public static boolean equals(float x, float y, int maxUlps) {\n-        int xInt = Float.floatToIntBits(x);\n-        int yInt = Float.floatToIntBits(y);\n+    public static boolean equals(final float x, final float y, final int maxUlps) {\n \n-        // Make lexicographically ordered as a two's-complement integer.\n-        if (xInt < 0) {\n-            xInt = SGN_MASK_FLOAT - xInt;\n+        final int xInt = Float.floatToRawIntBits(x);\n+        final int yInt = Float.floatToRawIntBits(y);\n+\n+        final boolean isEqual;\n+        if (((xInt ^ yInt) & SGN_MASK_FLOAT) == 0) {\n+            // number have same sign, there is no risk of overflow\n+            isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        } else {\n+            // number have opposite signs, take care of overflow\n+            final int deltaPlus;\n+            final int deltaMinus;\n+            if (xInt < yInt) {\n+                deltaPlus  = yInt - POSITIVE_ZERO_FLOAT_BITS;\n+                deltaMinus = xInt - NEGATIVE_ZERO_FLOAT_BITS;\n+            } else {\n+                deltaPlus  = xInt - POSITIVE_ZERO_FLOAT_BITS;\n+                deltaMinus = yInt - NEGATIVE_ZERO_FLOAT_BITS;\n             }\n-        if (yInt < 0) {\n-            yInt = SGN_MASK_FLOAT - yInt;\n+\n+            if (deltaPlus > maxUlps) {\n+                isEqual = false;\n+            } else {\n+                isEqual = deltaMinus <= (maxUlps - deltaPlus);\n             }\n \n-        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        }\n \n         return isEqual && !Float.isNaN(x) && !Float.isNaN(y);\n+\n     }\n \n     /**\n@@ -315,12 +339,16 @@ public static boolean equalsIncludingNaN(double x, double y, double eps) {\n     /**\n      * Returns true if both arguments are equal or within the range of allowed\n      * error (inclusive).\n+     * <p>\n      * Two float numbers are considered equal if there are {@code (maxUlps - 1)}\n-     * (or fewer) floating point numbers between them, i.e. two adjacent floating\n-     * point numbers are considered equal.\n+     * (or fewer) floating point numbers between them, i.e. two adjacent\n+     * floating point numbers are considered equal.\n+     * </p>\n+     * <p>\n      * Adapted from <a\n-     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * href=\"http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\">\n      * Bruce Dawson</a>\n+     * </p>\n      *\n      * @param x first value\n      * @param y second value\n@@ -329,21 +357,37 @@ public static boolean equalsIncludingNaN(double x, double y, double eps) {\n      * @return {@code true} if there are fewer than {@code maxUlps} floating\n      * point values between {@code x} and {@code y}.\n      */\n-    public static boolean equals(double x, double y, int maxUlps) {\n-        long xInt = Double.doubleToLongBits(x);\n-        long yInt = Double.doubleToLongBits(y);\n+    public static boolean equals(final double x, final double y, final int maxUlps) {\n \n-        // Make lexicographically ordered as a two's-complement integer.\n-        if (xInt < 0) {\n-            xInt = SGN_MASK - xInt;\n+        final long xInt = Double.doubleToRawLongBits(x);\n+        final long yInt = Double.doubleToRawLongBits(y);\n+\n+        final boolean isEqual;\n+        if (((xInt ^ yInt) & SGN_MASK) == 0l) {\n+            // number have same sign, there is no risk of overflow\n+            isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        } else {\n+            // number have opposite signs, take care of overflow\n+            final long deltaPlus;\n+            final long deltaMinus;\n+            if (xInt < yInt) {\n+                deltaPlus  = yInt - POSITIVE_ZERO_DOUBLE_BITS;\n+                deltaMinus = xInt - NEGATIVE_ZERO_DOUBLE_BITS;\n+            } else {\n+                deltaPlus  = xInt - POSITIVE_ZERO_DOUBLE_BITS;\n+                deltaMinus = yInt - NEGATIVE_ZERO_DOUBLE_BITS;\n             }\n-        if (yInt < 0) {\n-            yInt = SGN_MASK - yInt;\n+\n+            if (deltaPlus > maxUlps) {\n+                isEqual = false;\n+            } else {\n+                isEqual = deltaMinus <= (maxUlps - deltaPlus);\n             }\n \n-        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n+        }\n \n         return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n+\n     }\n \n     /**\n", 
  "project": "commons-math", 
  "linesAdd": 67, 
  "jira_id": "1127", 
  "nb_skipped": 3, 
  "commit": "ba62c59d", 
  "nb_failure": 1, 
  "linesRem": 23
}