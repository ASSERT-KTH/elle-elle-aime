{
  "files": 4, 
  "nb_test": 2152, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest", 
    "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest"
  ], 
  "patch": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\nindex 935bb8ba3..6ee9bd56c 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n@@ -271,7 +271,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n                         if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                            // rejecting the step would lead to a too small next step, we accept it\n+                            // we cannot simply truncate the step, reject the current computation\n+                            // and let the loop compute another state with the truncated step.\n+                            // it is so small (much probably exactly 0 due to limited accuracy)\n+                            // that the code above would fail handling it.\n+                            // So we set up an artificial 0 size step by copying states\n+                            interpolator.storeTime(stepStart);\n+                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                            hNew     = 0;\n+                            stepSize = 0;\n                             loop     = false;\n                         } else {\n                             // reject the step to match exactly the next switch time\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\nindex 27ade7b07..e0e2f0d2c 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n@@ -289,7 +289,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n                     if (manager.evaluateStep(interpolatorTmp)) {\n                         final double dt = manager.getEventTime() - stepStart;\n                         if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                            // rejecting the step would lead to a too small next step, we accept it\n+                            // we cannot simply truncate the step, reject the current computation\n+                            // and let the loop compute another state with the truncated step.\n+                            // it is so small (much probably exactly 0 due to limited accuracy)\n+                            // that the code above would fail handling it.\n+                            // So we set up an artificial 0 size step by copying states\n+                            interpolator.storeTime(stepStart);\n+                            System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                            hNew     = 0;\n+                            stepSize = 0;\n                             loop     = false;\n                         } else {\n                             // reject the step to match exactly the next switch time\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 34b3dc1ca..e03be9ed0 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -292,7 +292,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n           if (manager.evaluateStep(interpolator)) {\n               final double dt = manager.getEventTime() - stepStart;\n               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // rejecting the step would lead to a too small next step, we accept it\n+                  // we cannot simply truncate the step, reject the current computation\n+                  // and let the loop compute another state with the truncated step.\n+                  // it is so small (much probably exactly 0 due to limited accuracy)\n+                  // that the code above would fail handling it.\n+                  // So we set up an artificial 0 size step by copying states\n+                  interpolator.storeTime(stepStart);\n+                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                  hNew     = 0;\n+                  stepSize = 0;\n                   loop     = false;\n               } else {\n                   // reject the step to match exactly the next switch time\ndiff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\nindex 3227b9808..b61b0b1a4 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n@@ -172,7 +172,14 @@ public double integrate(final FirstOrderDifferentialEquations equations,\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                // rejecting the step would lead to a too small next step, we accept it\n+                // we cannot simply truncate the step, reject the current computation\n+                // and let the loop compute another state with the truncated step.\n+                // it is so small (much probably exactly 0 due to limited accuracy)\n+                // that the code above would fail handling it.\n+                // So we set up an artificial 0 size step by copying states\n+                interpolator.storeTime(stepStart);\n+                System.arraycopy(y, 0, yTmp, 0, y0.length);\n+                stepSize = 0;\n                 loop     = false;\n             } else {\n                 // reject the step to match exactly the next switch time\n", 
  "project": "commons-math", 
  "linesAdd": 35, 
  "jira_id": "358", 
  "nb_skipped": 0, 
  "commit": "061f5017", 
  "nb_failure": 2, 
  "linesRem": 4
}