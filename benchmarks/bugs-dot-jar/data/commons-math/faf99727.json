{
  "files": 2, 
  "nb_test": 5656, 
  "nb_error": 2, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.commons.math3.geometry.enclosing.WelzlEncloser2DTest"
  ], 
  "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java b/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java\nindex 4e9270430..a2e168455 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.commons.math3.geometry.enclosing;\n \n-import java.util.List;\n-\n import org.apache.commons.math3.geometry.Point;\n import org.apache.commons.math3.geometry.Space;\n \n@@ -34,6 +32,6 @@\n      * @param points points to enclose\n      * @return enclosing ball\n      */\n-    EnclosingBall<S, P> enclose(List<P> points);\n+    EnclosingBall<S, P> enclose(Iterable<P> points);\n \n }\ndiff --git a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\nindex ce5c58cb5..b8ea5d6bb 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java\n@@ -65,9 +65,9 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n     }\n \n     /** {@inheritDoc} */\n-    public EnclosingBall<S, P> enclose(final List<P> points) {\n+    public EnclosingBall<S, P> enclose(final Iterable<P> points) {\n \n-        if (points == null || points.isEmpty()) {\n+        if (points == null || !points.iterator().hasNext()) {\n             // return an empty ball\n             return generator.ballOnSupport(new ArrayList<P>());\n         }\n@@ -81,14 +81,14 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n      * @param points points to be enclosed\n      * @return enclosing ball\n      */\n-    private EnclosingBall<S, P> pivotingBall(final List<P> points) {\n+    private EnclosingBall<S, P> pivotingBall(final Iterable<P> points) {\n \n         List<P> extreme = new ArrayList<P>(max);\n         List<P> support = new ArrayList<P>(max);\n \n         // start with only first point selected as a candidate support\n-        extreme.add(points.get(0));\n-        EnclosingBall<S, P> ball = moveToFrontBall(extreme, support);\n+        extreme.add(points.iterator().next());\n+        EnclosingBall<S, P> ball = moveToFrontBall(extreme, extreme.size(), support);\n \n         while (true) {\n \n@@ -103,7 +103,7 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n             support.clear();\n             support.add(farthest);\n             EnclosingBall<S, P> savedBall = ball;\n-            ball = moveToFrontBall(extreme, support);\n+            ball = moveToFrontBall(extreme, extreme.size(), support);\n             if (ball.getRadius() < savedBall.getRadius()) {\n                 // TODO: fix this, it should never happen but it does!\n                 throw new MathInternalError();\n@@ -122,28 +122,31 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n \n     /** Compute enclosing ball using Welzl's move to front heuristic.\n      * @param extreme subset of extreme points\n+     * @param nbExtreme number of extreme points to consider\n      * @param support points that must belong to the ball support\n      * @return enclosing ball, for the extreme subset only\n      */\n-    private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final List<P> support) {\n+    private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final int nbExtreme,\n+                                                final List<P> support) {\n \n         // create a new ball on the prescribed support\n         EnclosingBall<S, P> ball = generator.ballOnSupport(support);\n \n         if (ball.getSupportSize() < max) {\n \n-            for (int i = 0; i < extreme.size(); ++i) {\n+            for (int i = 0; i < nbExtreme; ++i) {\n                 final P pi = extreme.get(i);\n                 if (!ball.contains(pi, tolerance)) {\n \n                     // we have found an outside point,\n                     // enlarge the ball by adding it to the support\n                     support.add(pi);\n-                    ball = moveToFrontBall(extreme.subList(i + 1, extreme.size()), support);\n+                    ball = moveToFrontBall(extreme, i, support);\n+                    support.remove(support.size() - 1);\n \n                     // it was an interesting point, move it to the front\n                     // according to Welzl's heuristic\n-                    for (int j = i; j > 1; --j) {\n+                    for (int j = i; j > 0; --j) {\n                         extreme.set(j, extreme.get(j - 1));\n                     }\n                     extreme.set(0, pi);\n@@ -162,7 +165,7 @@ protected WelzlEncloser(final double tolerance, final int dimension,\n      * @param ball current ball\n      * @return farthest point\n      */\n-    public P selectFarthest(final List<P> points, final EnclosingBall<S, P> ball) {\n+    public P selectFarthest(final Iterable<P> points, final EnclosingBall<S, P> ball) {\n \n         final P center = ball.getCenter();\n         P farthest   = null;\n", 
  "project": "commons-math", 
  "linesAdd": 15, 
  "jira_id": "1096", 
  "nb_skipped": 5, 
  "commit": "faf99727", 
  "nb_failure": 0, 
  "linesRem": 14
}