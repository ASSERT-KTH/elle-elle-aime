{
  "files": 1, 
  "nb_test": 4170, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSetTest"
  ], 
  "patch": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\nindex 9bd9daef6..9cb82def4 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -111,6 +111,20 @@ public PolygonsSet(final double xMin, final double xMax,\n      * constructor} using {@link SubHyperplane subhyperplanes}.</p>\n      * <p>If the list is empty, the region will represent the whole\n      * space.</p>\n+     * <p>\n+     * Polygons with thin pikes or dents are inherently difficult to handle because\n+     * they involve lines with almost opposite directions at some vertices. Polygons\n+     * whose vertices come from some physical measurement with noise are also\n+     * difficult because an edge that should be straight may be broken in lots of\n+     * different pieces with almost equal directions. In both cases, computing the\n+     * lines intersections is not numerically robust due to the almost 0 or almost\n+     * &pi; angle. Such cases need to carefully adjust the {@code hyperplaneThickness}\n+     * parameter. A too small value would often lead to completely wrong polygons\n+     * with large area wrongly identified as inside or outside. Large values are\n+     * often much safer. As a rule of thumb, a value slightly below the size of the\n+     * most accurate detail needed is a good value for the {@code hyperplaneThickness}\n+     * parameter.\n+     * </p>\n      * @param hyperplaneThickness tolerance below which points are considered to\n      * belong to the hyperplane (which is therefore more a slab)\n      * @param vertices vertices of the simple loop boundary\n@@ -157,20 +171,50 @@ public PolygonsSet(final double hyperplaneThickness, final Vector2D ... vertices\n     private static BSPTree<Euclidean2D> verticesToTree(final double hyperplaneThickness,\n                                                        final Vector2D ... vertices) {\n \n-        if (vertices.length == 0) {\n+        final int n = vertices.length;\n+        if (n == 0) {\n             // the tree represents the whole space\n             return new BSPTree<Euclidean2D>(Boolean.TRUE);\n         }\n \n-        // at start, none of the edges have been processed\n-        final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>();\n-        List<Vertex> list = new ArrayList<PolygonsSet.Vertex>(vertices.length);\n-        for (final Vector2D vertex : vertices) {\n-            list.add(new Vertex(vertex));\n+        // build the vertices\n+        final Vertex[] vArray = new Vertex[n];\n+        for (int i = 0; i < n; ++i) {\n+            vArray[i] = new Vertex(vertices[i]);\n+        }\n+\n+        // build the edges\n+        List<Edge> edges = new ArrayList<Edge>();\n+        for (int i = 0; i < n; ++i) {\n+\n+            // get the endpoints of the edge\n+            final Vertex start = vArray[i];\n+            final Vertex end   = vArray[(i + 1) % n];\n+\n+            // get the line supporting the edge, taking care not to recreate it\n+            // if it was already created earlier due to another edge being aligned\n+            // with the current one\n+            Line line = start.sharedLineWith(end);\n+            if (line == null) {\n+                line = new Line(start.getLocation(), end.getLocation());\n+            }\n+\n+            // create the edge and store it\n+            edges.add(new Edge(start, end, line));\n+\n+            // check if another vertex also happens to be on this line\n+            for (final Vertex vertex : vArray) {\n+                if (vertex != start && vertex != end &&\n+                    FastMath.abs(line.getOffset(vertex.getLocation())) <= hyperplaneThickness) {\n+                    vertex.bindWith(line);\n+                }\n+            }\n+\n         }\n \n         // build the tree top-down\n-        insertVertices(hyperplaneThickness, tree, list);\n+        final BSPTree<Euclidean2D> tree = new BSPTree<Euclidean2D>();\n+        insertEdges(hyperplaneThickness, tree, edges);\n \n         return tree;\n \n@@ -181,45 +225,32 @@ public PolygonsSet(final double hyperplaneThickness, final Vector2D ... vertices\n      * belong to the hyperplane (which is therefore more a slab)\n      * @param node current tree node (it is a leaf node at the beginning\n      * of the call)\n-     * @param vertices list of vertices belonging to the boundary of the\n-     * cell defined by the node\n+     * @param edges list of edges to insert in the cell defined by this node\n+     * (excluding edges not belonging to the cell defined by this node)\n      */\n-    private static void insertVertices(final double hyperplaneThickness,\n+    private static void insertEdges(final double hyperplaneThickness,\n                                     final BSPTree<Euclidean2D> node,\n-                                       final List<Vertex> vertices) {\n+                                    final List<Edge> edges) {\n \n-        Vertex current = vertices.get(vertices.size() - 1);\n+        // find an edge with an hyperplane that can be inserted in the node\n         int index = 0;\n-        Line inserted = null;\n-        while (inserted == null && index < vertices.size()) {\n-            final Vertex previous = current;\n-            current = vertices.get(index++);\n-            if (previous.outgoingNeedsProcessing() && current.incomingNeedsProcessing()) {\n-\n-                if (previous.shareNodeWith(current)) {\n-                    // both vertices are already handled by an existing node,\n-                    // closer to the tree root, they were probably created\n-                    // when split points were introduced\n-                    inserted = null;\n-                } else {\n-\n-                    inserted = new Line(previous.getLocation(), current.getLocation());\n-\n-                    if (node.insertCut(inserted)) {\n-                        previous.addNode(node);\n-                        previous.outgoingProcessed();\n-                        current.addNode(node);\n-                        current.incomingProcessed();\n+        Edge inserted =null;\n+        while (inserted == null && index < edges.size()) {\n+            inserted = edges.get(index++);\n+            if (inserted.getNode() == null) {\n+                if (node.insertCut(inserted.getLine())) {\n+                    inserted.setNode(node);\n                 } else {\n                     inserted = null;\n                 }\n-\n-                }\n-\n+            } else {\n+                inserted = null;\n             }\n         }\n \n-        if (node.getCut() == null) {\n+        if (inserted == null) {\n+            // no suitable edge was found, the node remains a leaf node\n+            // we need to set its inside/outside boolean indicator\n             final BSPTree<Euclidean2D> parent = node.getParent();\n             if (parent == null || node == parent.getMinus()) {\n                 node.setAttribute(Boolean.TRUE);\n@@ -229,67 +260,58 @@ private static void insertVertices(final double hyperplaneThickness,\n             return;\n         }\n \n-        // distribute the remaining vertices in the two sub-trees\n-        Side currentSide = Side.HYPER;\n-        final List<Vertex> plusList  = new ArrayList<Vertex>();\n-        plusList.add(current);\n-        int plusCount = 0;\n-        final List<Vertex> minusList = new ArrayList<Vertex>();\n-        minusList.add(current);\n-        int minusCount = 0;\n-        while (index < vertices.size()) {\n-            final Vertex previous = current;\n-            final Side previousSide = currentSide;\n-            current = vertices.get(index++);\n-            final double currentOffset = inserted.getOffset(current.getLocation());\n-            currentSide = (FastMath.abs(currentOffset) <= hyperplaneThickness) ?\n-                           Side.HYPER :\n-                           ((currentOffset < 0) ? Side.MINUS : Side.PLUS);\n-            switch (currentSide) {\n+        // we have split the node by inserted an edge as a cut sub-hyperplane\n+        // distribute the remaining edges in the two sub-trees\n+        final List<Edge> plusList  = new ArrayList<Edge>();\n+        final List<Edge> minusList = new ArrayList<Edge>();\n+        for (final Edge edge : edges) {\n+            if (edge != inserted) {\n+                final double startOffset = inserted.getLine().getOffset(edge.getStart().getLocation());\n+                final double endOffset   = inserted.getLine().getOffset(edge.getEnd().getLocation());\n+                Side startSide = (FastMath.abs(startOffset) <= hyperplaneThickness) ?\n+                                 Side.HYPER : ((startOffset < 0) ? Side.MINUS : Side.PLUS);\n+                Side endSide   = (FastMath.abs(endOffset) <= hyperplaneThickness) ?\n+                                 Side.HYPER : ((endOffset < 0) ? Side.MINUS : Side.PLUS);\n+                switch (startSide) {\n                     case PLUS:\n-                if (previousSide == Side.MINUS) {\n+                        if (endSide == Side.MINUS) {\n                             // we need to insert a split point on the hyperplane\n-                    final Line line = new Line(previous.getLocation(), current.getLocation());\n-                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\n-                    splitPoint.addNode(node);\n-                    minusList.add(splitPoint);\n-                    plusList.add(splitPoint);\n-                }\n-                plusList.add(current);\n-                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\n-                    ++plusCount;\n+                            final Vertex splitPoint = edge.split(inserted.getLine());\n+                            minusList.add(splitPoint.getOutgoing());\n+                            plusList.add(splitPoint.getIncoming());\n+                        } else {\n+                            plusList.add(edge);\n                         }\n                         break;\n                     case MINUS:\n-                if (previousSide == Side.PLUS) {\n+                        if (endSide == Side.PLUS) {\n                             // we need to insert a split point on the hyperplane\n-                    final Line line = new Line(previous.getLocation(), current.getLocation());\n-                    final Vertex splitPoint = new Vertex(inserted.intersection(line));\n-                    splitPoint.addNode(node);\n-                    minusList.add(splitPoint);\n-                    plusList.add(splitPoint);\n-                }\n-                minusList.add(current);\n-                if (current.incomingNeedsProcessing() || current.outgoingNeedsProcessing()) {\n-                    ++minusCount;\n+                            final Vertex splitPoint = edge.split(inserted.getLine());\n+                            minusList.add(splitPoint.getIncoming());\n+                            plusList.add(splitPoint.getOutgoing());\n+                        } else {\n+                            minusList.add(edge);\n                         }\n                         break;\n                     default:\n-                current.addNode(node);\n-                plusList.add(current);\n-                minusList.add(current);\n+                        if (endSide == Side.PLUS) {\n+                            plusList.add(edge);\n+                        } else if (endSide == Side.MINUS) {\n+                            minusList.add(edge);\n+                        }\n                         break;\n                 }\n             }\n+        }\n \n         // recurse through lower levels\n-        if (plusCount > 0) {\n-            insertVertices(hyperplaneThickness, node.getPlus(),  plusList);\n+        if (!plusList.isEmpty()) {\n+            insertEdges(hyperplaneThickness, node.getPlus(),  plusList);\n         } else {\n             node.getPlus().setAttribute(Boolean.FALSE);\n         }\n-        if (minusCount > 0) {\n-            insertVertices(hyperplaneThickness, node.getMinus(), minusList);\n+        if (!minusList.isEmpty()) {\n+            insertEdges(hyperplaneThickness, node.getMinus(), minusList);\n         } else {\n             node.getMinus().setAttribute(Boolean.TRUE);\n         }\n@@ -302,23 +324,23 @@ private static void insertVertices(final double hyperplaneThickness,\n         /** Vertex location. */\n         private final Vector2D location;\n \n-        /** Nodes associated with the hyperplane containing this vertex. */\n-        private final List<BSPTree<Euclidean2D>> nodes;\n+        /** Incoming edge. */\n+        private Edge incoming;\n \n-        /** Indicator for incoming edges that still need processing. */\n-        private boolean incomingNeedsProcessing;\n+        /** Outgoing edge. */\n+        private Edge outgoing;\n \n-        /** Indicator for outgoing edges that still need processing. */\n-        private boolean outgoingNeedsProcessing;\n+        /** Lines bound with this vertex. */\n+        private final List<Line> lines;\n \n         /** Build a non-processed vertex not owned by any node yet.\n          * @param location vertex location\n          */\n         public Vertex(final Vector2D location) {\n             this.location = location;\n-            this.nodes                   = new ArrayList<BSPTree<Euclidean2D>>();\n-            this.incomingNeedsProcessing = true;\n-            this.outgoingNeedsProcessing = true;\n+            this.incoming = null;\n+            this.outgoing = null;\n+            this.lines    = new ArrayList<Line>();\n         }\n \n         /** Get Vertex location.\n@@ -328,57 +350,160 @@ public Vector2D getLocation() {\n             return location;\n         }\n \n-        /** Check if the instance and another vertex share a node.\n+        /** Bind a line considered to contain this vertex.\n+         * @param line line to bind with this vertex\n+         */\n+        public void bindWith(final Line line) {\n+            lines.add(line);\n+        }\n+\n+        /** Get the common line bound with both the instance and another vertex, if any.\n          * <p>\n-         * When two vertices share a node, this means they are already handled\n-         * by the hyperplane of this node, so there is no need to create a cut\n-         * hyperplane for them.\n+         * When two vertices are both bound to the same line, this means they are\n+         * already handled by node associated with this line, so there is no need\n+         * to create a cut hyperplane for them.\n          * </p>\n          * @param vertex other vertex to check instance against\n-         * @return true if the instance and another vertex share a node\n+         * @return line bound with both the instance and another vertex, or null if the\n+         * two vertices do not share a line yet\n          */\n-        public boolean shareNodeWith(final Vertex vertex) {\n-            for (final BSPTree<Euclidean2D> node1 : nodes) {\n-                for (final BSPTree<Euclidean2D> node2 : vertex.nodes) {\n-                    if (node1 == node2) {\n-                        return true;\n+        public Line sharedLineWith(final Vertex vertex) {\n+            for (final Line line1 : lines) {\n+                for (final Line line2 : vertex.lines) {\n+                    if (line1 == line2) {\n+                        return line1;\n                     }\n                 }\n             }\n-            return false;\n+            return null;\n         }\n \n-        /** Add a node whose hyperplane contains this vertex.\n-         * @param node node whose hyperplane contains this vertex\n+        /** Set incoming edge.\n+         * <p>\n+         * The line supporting the incoming edge is automatically bound\n+         * with the instance.\n+         * </p>\n+         * @param incoming incoming edge\n+         */\n+        public void setIncoming(final Edge incoming) {\n+            this.incoming = incoming;\n+            bindWith(incoming.getLine());\n+        }\n+\n+        /** Get incoming edge.\n+         * @return incoming edge\n+         */\n+        public Edge getIncoming() {\n+            return incoming;\n+        }\n+\n+        /** Set outgoing edge.\n+         * <p>\n+         * The line supporting the outgoing edge is automatically bound\n+         * with the instance.\n+         * </p>\n+         * @param incoming outgoing edge\n+         */\n+        public void setOutgoing(final Edge outgoing) {\n+            this.outgoing = outgoing;\n+            bindWith(outgoing.getLine());\n+        }\n+\n+        /** Get outgoing edge.\n+         * @return outgoing edge\n+         */\n+        public Edge getOutgoing() {\n+            return outgoing;\n+        }\n+\n+    }\n+\n+    /** Internal class for holding edges while they are processed to build a BSP tree. */\n+    private static class Edge {\n+\n+        /** Start vertex. */\n+        private final Vertex start;\n+\n+        /** End vertex. */\n+        private final Vertex end;\n+\n+        /** Line supporting the edge. */\n+        private final Line line;\n+\n+        /** Node whose cut hyperplane contains this edge. */\n+        private BSPTree<Euclidean2D> node;\n+\n+        /** Build an edge not contained in any node yet.\n+         * @param start start vertex\n+         * @param end end vertex\n+         * @param line line supporting the edge\n          */\n-        public void addNode(final BSPTree<Euclidean2D> node) {\n-            nodes.add(node);\n+        public Edge(final Vertex start, final Vertex end, final Line line) {\n+\n+            this.start = start;\n+            this.end   = end;\n+            this.line  = line;\n+            this.node  = null;\n+\n+            // connect the vertices back to the edge\n+            start.setOutgoing(this);\n+            end.setIncoming(this);\n+\n         }\n \n-        /** Check incoming edge processed indicator.\n-         * @return true if incoming edge needs processing\n+        /** Get start vertex.\n+         * @return start vertex\n          */\n-        public boolean incomingNeedsProcessing() {\n-            return incomingNeedsProcessing;\n+        public Vertex getStart() {\n+            return start;\n         }\n \n-        /** Check outgoing edge processed indicator.\n-         * @return true if outgoing edge needs processing\n+        /** Get end vertex.\n+         * @return end vertex\n          */\n-        public boolean outgoingNeedsProcessing() {\n-            return outgoingNeedsProcessing;\n+        public Vertex getEnd() {\n+            return end;\n         }\n \n-        /** Mark the incoming edge as processed.\n+        /** Get the line supporting this edge.\n+         * @return line supporting this edge\n          */\n-        public void incomingProcessed() {\n-            incomingNeedsProcessing = false;\n+        public Line getLine() {\n+            return line;\n         }\n \n-        /** Mark the outgoing edge as processed.\n+        /** Set the node whose cut hyperplane contains this edge.\n+         * @param node node whose cut hyperplane contains this edge\n+         */\n+        public void setNode(final BSPTree<Euclidean2D> node) {\n+            this.node = node;\n+        }\n+\n+        /** Get the node whose cut hyperplane contains this edge.\n+         * @return node whose cut hyperplane contains this edge\n+         * (null if edge has not yet been inserted into the BSP tree)\n+         */\n+        public BSPTree<Euclidean2D> getNode() {\n+            return node;\n+        }\n+\n+        /** Split the edge.\n+         * <p>\n+         * Once split, this edge is not referenced anymore by the vertices,\n+         * it is replaced by the two half-edges and an intermediate splitting\n+         * vertex is introduced to connect these two halves.\n+         * </p>\n+         * @param splitLine line splitting the edge in two halves\n+         * @return split vertex (its incoming and outgoing edges are the two halves)\n          */\n-        public void outgoingProcessed() {\n-            outgoingNeedsProcessing = false;\n+        public Vertex split(final Line splitLine) {\n+            final Vertex splitVertex = new Vertex(line.intersection(splitLine));\n+            splitVertex.bindWith(splitLine);\n+            final Edge startHalf = new Edge(start, splitVertex, line);\n+            final Edge endHalf   = new Edge(splitVertex, end, line);\n+            startHalf.node = node;\n+            endHalf.node   = node;\n+            return splitVertex;\n         }\n \n     }\n", 
  "project": "commons-math", 
  "linesAdd": 243, 
  "jira_id": "880", 
  "nb_skipped": 4, 
  "commit": "2a9cbbab", 
  "nb_failure": 2, 
  "linesRem": 118
}