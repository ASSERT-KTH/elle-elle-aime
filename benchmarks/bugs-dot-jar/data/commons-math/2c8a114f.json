{
  "files": 1, 
  "nb_test": 2081, 
  "nb_error": 3, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.commons.math.random.RandomDataTest", 
    "org.apache.commons.math.random.AbstractRandomGeneratorTest", 
    "org.apache.commons.math.random.RandomAdaptorTest"
  ], 
  "patch": "diff --git a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\nindex 18097bcca..d5d2474f7 100644\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n@@ -322,30 +322,17 @@ public long nextSecureLong(long lower, long upper) {\n     /**\n      * {@inheritDoc}\n      * <p>\n-     * <strong>Algorithm Description</strong>: For small means, uses simulation\n-     * of a Poisson process using Uniform deviates, as described <a\n-     * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n-     * </p>\n-     * <p>\n-     * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n-     * </p>\n-     *\n-     * <p>\n-     * For large means, uses a reject method as described in <a\n-     * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n-     * Variate Generation</a>\n-     * </p>\n+     * <strong>Algorithm Description</strong>:\n+     * <ul><li> For small means, uses simulation of a Poisson process\n+     * using Uniform deviates, as described\n+     * <a href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n+     * The Poisson process (and hence value returned) is bounded by 1000 * mean.</li>\n      *\n-     * <p>\n-     * References:\n-     * <ul>\n-     * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n-     * New York, NY. Springer-Verlag</li>\n-     * </ul>\n-     * </p>\n+     * <li> For large means, uses the rejection algorithm described in <br/>\n+     * Devroye, Luc. (1981).<i>The Computer Generation of Poisson Random Variables</i>\n+     * <strong>Computing</strong> vol. 26 pp. 197-207.</li></ul></p>\n      *\n-     * @param mean\n-     *            mean of the Poisson distribution.\n+     * @param mean mean of the Poisson distribution.\n      * @return the random Poisson value.\n      */\n     public long nextPoisson(double mean) {\n@@ -356,7 +343,7 @@ public long nextPoisson(double mean) {\n \n         final RandomGenerator generator = getRan();\n \n-        double pivot = 6.0;\n+        final double pivot = 40.0d;\n         if (mean < pivot) {\n             double p = Math.exp(-mean);\n             long n = 0;\n@@ -374,68 +361,70 @@ public long nextPoisson(double mean) {\n             }\n             return n;\n         } else {\n-            double mu = Math.floor(mean);\n-            double delta = Math.floor(pivot + (mu - pivot) / 2.0); // integer\n-            // between 6\n-            // and mean\n-            double mu2delta = 2.0 * mu + delta;\n-            double muDeltaHalf = mu + delta / 2.0;\n-            double logMeanMu = Math.log(mean / mu);\n-\n-            double muFactorialLog = MathUtils.factorialLog((int) mu);\n-\n-            double c1 = Math.sqrt(Math.PI * mu / 2.0);\n-            double c2 = c1 +\n-                        Math.sqrt(Math.PI * muDeltaHalf /\n-                                  (2.0 * Math.exp(1.0 / mu2delta)));\n-            double c3 = c2 + 2.0;\n-            double c4 = c3 + Math.exp(1.0 / 78.0);\n-            double c = c4 + 2.0 / delta * mu2delta *\n-                       Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n-\n-            double y = 0.0;\n-            double x = 0.0;\n-            double w = Double.POSITIVE_INFINITY;\n-\n-            boolean accept = false;\n-            while (!accept) {\n-                double u = nextUniform(0.0, c);\n-                double e = nextExponential(mean);\n-\n-                if (u <= c1) {\n-                    double z = nextGaussian(0.0, 1.0);\n-                    y = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n-                    x = Math.floor(y);\n-                    w = -z * z / 2.0 - e - x * logMeanMu;\n-                    if (x < -mu) {\n-                        w = Double.POSITIVE_INFINITY;\n-                    }\n-                } else if (c1 < u && u <= c2) {\n-                    double z = nextGaussian(0.0, 1.0);\n-                    y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n-                    x = Math.ceil(y);\n-                    w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n-                    if (x > delta) {\n-                        w = Double.POSITIVE_INFINITY;\n-                    }\n-                } else if (c2 < u && u <= c3) {\n-                    x = 0.0;\n-                    w = -e;\n-                } else if (c3 < u && u <= c4) {\n-                    x = 1.0;\n-                    w = -e - logMeanMu;\n-                } else if (c4 < u) {\n-                    double v = nextExponential(mean);\n-                    y = delta + v * 2.0 / delta * mu2delta;\n-                    x = Math.ceil(y);\n-                    w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n-                }\n-                accept = w <= x * Math.log(mu) -\n-                         MathUtils.factorialLog((int) (mu + x)) / muFactorialLog;\n-            }\n-            // cast to long is acceptable because both x and mu are whole\n-            // numbers.\n-            return (long) (x + mu);\n+            final double lambda = Math.floor(mean);\n+            final double lambdaFractional = mean - lambda;\n+            final double logLambda = Math.log(lambda);\n+            final double logLambdaFactorial = MathUtils.factorialLog((int) lambda);\n+            final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);\n+            final double delta = Math.sqrt(lambda * Math.log(32 * lambda / Math.PI + 1));\n+            final double halfDelta = delta / 2;\n+            final double twolpd = 2 * lambda + delta;\n+            final double a1 = Math.sqrt(Math.PI * twolpd) * Math.exp(1 / 8 * lambda);\n+            final double a2 = (twolpd / delta) * Math.exp(-delta * (1 + delta) / twolpd);\n+            final double aSum = a1 + a2 + 1;\n+            final double p1 = a1 / aSum;\n+            final double p2 = a2 / aSum;\n+            final double c1 = 1 / (8 * lambda);\n+\n+            double x = 0;\n+            double y = 0;\n+            double v = 0;\n+            int a = 0;\n+            double t = 0;\n+            double qr = 0;\n+            double qa = 0;\n+            for (;;) {\n+                final double u = nextUniform(0.0, 1);\n+                if (u <= p1) {\n+                    final double n = nextGaussian(0d, 1d);\n+                    x = n * Math.sqrt(lambda + halfDelta) - 0.5d;\n+                    if (x > delta || x < -lambda) {\n+                        continue;\n+                    }\n+                    y = x < 0 ? Math.floor(x) : Math.ceil(x);\n+                    final double e = nextExponential(1d);\n+                    v = -e - (n * n / 2) + c1;\n+                } else {\n+                    if (u > p1 + p2) {\n+                        y = lambda;\n+                        break;\n+                    } else {\n+                        x = delta + (twolpd / delta) * nextExponential(1d);\n+                        y = Math.ceil(x);\n+                        v = -nextExponential(1d) - delta * (x + 1) / twolpd;\n+                    }\n+                }\n+                a = x < 0 ? 1 : 0;\n+                t = y * (y + 1) / (2 * lambda);\n+                if (v < -t && a == 0) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+                qr = t * ((2 * y + 1) / (6 * lambda) - 1);\n+                qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));\n+                if (v < qa) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+                if (v > qr) {\n+                    continue;\n+                }\n+                if (v < y * logLambda - MathUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {\n+                    y = lambda + y;\n+                    break;\n+                }\n+            }\n+            return y2 + (long) y;\n         }\n     }\n \n", 
  "project": "commons-math", 
  "linesAdd": 74, 
  "jira_id": "294", 
  "nb_skipped": 0, 
  "commit": "2c8a114f", 
  "nb_failure": 0, 
  "linesRem": 85
}