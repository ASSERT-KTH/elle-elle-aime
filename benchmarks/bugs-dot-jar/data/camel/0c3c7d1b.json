{
  "files": 2, 
  "nb_test": 4318, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.camel.impl.DefaultProducerCacheTest"
  ], 
  "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java\nindex 16be6ab378..cadb98a1ea 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ConsumerCache.java\n@@ -27,7 +27,6 @@\n import org.apache.camel.support.ServiceSupport;\n import org.apache.camel.util.CamelContextHelper;\n import org.apache.camel.util.LRUCache;\n-import org.apache.camel.util.LRUSoftCache;\n import org.apache.camel.util.ServiceHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -60,14 +59,17 @@ public ConsumerCache(Object source, CamelContext camelContext, Map<String, Polli\n     /**\n      * Creates the {@link LRUCache} to be used.\n      * <p/>\n-     * This implementation returns a {@link org.apache.camel.util.LRUSoftCache} instance.\n+     * This implementation returns a {@link LRUCache} instance.\n \n      * @param cacheSize the cache size\n      * @return the cache\n      */\n     protected static LRUCache<String, PollingConsumer> createLRUCache(int cacheSize) {\n-        // We use a soft reference cache to allow the JVM to re-claim memory if it runs low on memory.\n-        return new LRUSoftCache<String, PollingConsumer>(cacheSize);\n+        // Use a regular cache as we want to ensure that the lifecycle of the consumers\n+        // being cache is properly handled, such as they are stopped when being evicted\n+        // or when this cache is stopped. This is needed as some consumers requires to\n+        // be stopped so they can shutdown internal resources that otherwise may cause leaks\n+        return new LRUCache<String, PollingConsumer>(cacheSize);\n     }\n \n     public synchronized PollingConsumer getConsumer(Endpoint endpoint) {\ndiff --git a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\nindex 89fadb0881..8c5f97688c 100644\n--- a/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n+++ b/camel-core/src/main/java/org/apache/camel/impl/ProducerCache.java\n@@ -37,7 +37,6 @@\n import org.apache.camel.util.CamelContextHelper;\n import org.apache.camel.util.EventHelper;\n import org.apache.camel.util.LRUCache;\n-import org.apache.camel.util.LRUSoftCache;\n import org.apache.camel.util.ServiceHelper;\n import org.apache.camel.util.StopWatch;\n import org.slf4j.Logger;\n@@ -78,14 +77,17 @@ public ProducerCache(Object source, CamelContext camelContext, ServicePool<Endpo\n     /**\n      * Creates the {@link LRUCache} to be used.\n      * <p/>\n-     * This implementation returns a {@link LRUSoftCache} instance.\n+     * This implementation returns a {@link LRUCache} instance.\n \n      * @param cacheSize the cache size\n      * @return the cache\n      */\n     protected static LRUCache<String, Producer> createLRUCache(int cacheSize) {\n-        // We use a soft reference cache to allow the JVM to re-claim memory if it runs low on memory.\n-        return new LRUSoftCache<String, Producer>(cacheSize);\n+        // Use a regular cache as we want to ensure that the lifecycle of the producers\n+        // being cache is properly handled, such as they are stopped when being evicted\n+        // or when this cache is stopped. This is needed as some producers requires to\n+        // be stopped so they can shutdown internal resources that otherwise may cause leaks\n+        return new LRUCache<String, Producer>(cacheSize);\n     }\n \n     public CamelContext getCamelContext() {\n", 
  "project": "camel", 
  "linesAdd": 12, 
  "jira_id": "5683", 
  "nb_skipped": 1, 
  "commit": "0c3c7d1b", 
  "nb_failure": 1, 
  "linesRem": 8
}