{
  "files": 1, 
  "nb_test": 2999, 
  "nb_error": 1, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.camel.issues.SplitterThrowExceptionInExpressionTest"
  ], 
  "patch": "diff --git a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\nindex fcb8bfc150..bdee56f5a9 100644\n--- a/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n+++ b/camel-core/src/main/java/org/apache/camel/processor/MulticastProcessor.java\n@@ -174,10 +174,16 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n \n         // multicast uses fine grained error handling on the output processors\n         // so use try .. catch to cater for this\n+        boolean exhaust = false;\n         try {\n             boolean sync = true;\n \n             pairs = createProcessorExchangePairs(exchange);\n+\n+            // after we have created the processors we consider the exchange as exhausted if an unhandled\n+            // exception was thrown, (used in the catch block)\n+            exhaust = true;\n+\n             if (isParallelProcessing()) {\n                 // ensure an executor is set when running in parallel\n                 ObjectHelper.notNull(executorService, \"executorService\", this);\n@@ -194,14 +200,14 @@ public boolean process(Exchange exchange, AsyncCallback callback) {\n         } catch (Throwable e) {\n             exchange.setException(e);\n             // and do the done work\n-            doDone(exchange, null, callback, true);\n+            doDone(exchange, null, callback, true, exhaust);\n             return true;\n         }\n \n         // multicasting was processed successfully\n         // and do the done work\n         Exchange subExchange = result.get() != null ? result.get() : null;\n-        doDone(exchange, subExchange, callback, true);\n+        doDone(exchange, subExchange, callback, true, exhaust);\n         return true;\n     }\n \n@@ -455,7 +461,7 @@ public void done(boolean doneSync) {\n                             result.set(subExchange);\n                         }\n                         // and do the done work\n-                        doDone(original, subExchange, callback, false);\n+                        doDone(original, subExchange, callback, false, true);\n                         return;\n                     }\n \n@@ -465,7 +471,7 @@ public void done(boolean doneSync) {\n                         // wrap in exception to explain where it failed\n                         subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\n                         // and do the done work\n-                        doDone(original, subExchange, callback, false);\n+                        doDone(original, subExchange, callback, false, true);\n                         return;\n                     }\n \n@@ -501,7 +507,7 @@ public void done(boolean doneSync) {\n                                 result.set(subExchange);\n                             }\n                             // and do the done work\n-                            doDone(original, subExchange, callback, false);\n+                            doDone(original, subExchange, callback, false, true);\n                             return;\n                         }\n \n@@ -511,7 +517,7 @@ public void done(boolean doneSync) {\n                             // wrap in exception to explain where it failed\n                             subExchange.setException(new CamelExchangeException(\"Sequential processing failed for number \" + total, subExchange, e));\n                             // and do the done work\n-                            doDone(original, subExchange, callback, false);\n+                            doDone(original, subExchange, callback, false, true);\n                             return;\n                         }\n \n@@ -520,7 +526,7 @@ public void done(boolean doneSync) {\n \n                     // do the done work\n                     subExchange = result.get() != null ? result.get() : null;\n-                    doDone(original, subExchange, callback, false);\n+                    doDone(original, subExchange, callback, false, true);\n                 }\n             });\n         } finally {\n@@ -589,15 +595,16 @@ private void doProcessParallel(final ProcessorExchangePair pair) throws Exceptio\n      * @param subExchange the current sub exchange, can be <tt>null</tt> for the synchronous part\n      * @param callback    the callback\n      * @param doneSync    the <tt>doneSync</tt> parameter to call on callback\n+     * @param exhaust     whether or not error handling is exhausted\n      */\n-    protected void doDone(Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync) {\n+    protected void doDone(Exchange original, Exchange subExchange, AsyncCallback callback, boolean doneSync, boolean exhaust) {\n         // cleanup any per exchange aggregation strategy\n         removeAggregationStrategyFromExchange(original);\n         if (original.getException() != null) {\n             // multicast uses error handling on its output processors and they have tried to redeliver\n             // so we shall signal back to the other error handlers that we are exhausted and they should not\n             // also try to redeliver as we will then do that twice\n-            original.setProperty(Exchange.REDELIVERY_EXHAUSTED, Boolean.TRUE);\n+            original.setProperty(Exchange.REDELIVERY_EXHAUSTED, exhaust);\n         }\n         if (subExchange != null) {\n             // and copy the current result to original so it will contain this exception\n", 
  "project": "camel", 
  "linesAdd": 16, 
  "jira_id": "3394", 
  "nb_skipped": 0, 
  "commit": "18e1a142", 
  "nb_failure": 0, 
  "linesRem": 9
}