{
  "files": 1, 
  "nb_test": 1890, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.jackrabbit.oak.security.authorization.permission.PermissionEntryProviderImplTest"
  ], 
  "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java\nindex cce6a71406..d77fe973cc 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/security/authorization/permission/PermissionEntryProviderImpl.java\n@@ -28,10 +29,14 @@\n \n import com.google.common.base.Strings;\n import com.google.common.collect.Iterators;\n+import com.google.common.math.LongMath;\n+\n import org.apache.jackrabbit.commons.iterator.AbstractLazyIterator;\n import org.apache.jackrabbit.oak.api.Tree;\n import org.apache.jackrabbit.oak.spi.security.ConfigurationParameters;\n import org.apache.jackrabbit.oak.spi.security.authorization.accesscontrol.AccessControlConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n class PermissionEntryProviderImpl implements PermissionEntryProvider {\n \n@@ -39,18 +44,31 @@\n \n     private static final long DEFAULT_SIZE = 250;\n \n+    private static final Logger log = LoggerFactory.getLogger(PermissionEntryProviderImpl.class);\n+\n+    /**\n+     * The set of principal names for which this {@code PermissionEntryProvider}\n+     * has been created.\n+     */\n     private final Set<String> principalNames;\n \n+    /**\n+     * The set of principal names for which the store contains any permission\n+     * entries. This set is equals or just a subset of the {@code principalNames}\n+     * defined above. The methods collecting the entries will shortcut in case\n+     * this set is empty and thus no permission entries exist for the specified\n+     * set of principal.\n+     */\n     private final Set<String> existingNames = new HashSet<String>();\n \n-    private Map<String, Collection<PermissionEntry>> pathEntryMap;\n-\n     private final PermissionStore store;\n \n     private final PermissionEntryCache cache;\n \n     private final long maxSize;\n \n+    private Map<String, Collection<PermissionEntry>> pathEntryMap;\n+\n     PermissionEntryProviderImpl(@Nonnull PermissionStore store, @Nonnull PermissionEntryCache cache,\n                                 @Nonnull Set<String> principalNames, @Nonnull ConfigurationParameters options) {\n         this.store = store;\n@@ -65,15 +83,40 @@ private void init() {\n         existingNames.clear();\n         for (String name : principalNames) {\n             long n = cache.getNumEntries(store, name, maxSize);\n-            cnt+= n;\n+            /*\n+            if cache.getNumEntries (n) returns a number bigger than 0, we\n+            remember this principal name int the 'existingNames' set\n+            */\n             if (n > 0) {\n                 existingNames.add(name);\n             }\n+            /*\n+            Calculate the total number of permission entries (cnt) defined for the\n+            given set of principals in order to be able to determine if the cache\n+            should be loaded upfront.\n+            Note however that cache.getNumEntries (n) may return Long.MAX_VALUE\n+            if the underlying implementation does not know the exact value, and\n+            the child node count is higher than maxSize (see OAK-2465).\n+            */                        \n+            if (cnt < Long.MAX_VALUE) {\n+                if (Long.MAX_VALUE == n) {\n+                    cnt = Long.MAX_VALUE;\n+                } else {\n+                    try {\n+                        cnt = LongMath.checkedAdd(cnt, n);\n+                    } catch (ArithmeticException ae) {\n+                        log.warn(\"Long overflow while calculate the total number of permission entries\");\n+                        cnt = Long.MAX_VALUE;\n+                    }\n                 }\n-        if (cnt < maxSize) {\n-            // cache all entries of all principals\n+            }\n+        }\n+\n+        if (cnt > 0 && cnt < maxSize) {\n+            // the total number of entries is smaller that maxSize, so we can\n+            // cache all entries for all principals having any entries right away\n             pathEntryMap = new HashMap<String, Collection<PermissionEntry>>();\n-            for (String name: principalNames) {\n+            for (String name : existingNames) {\n                 cache.load(store, pathEntryMap, name);\n             }\n         } else {\n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 48, 
  "jira_id": "2465", 
  "nb_skipped": 9, 
  "commit": "60186813", 
  "nb_failure": 3, 
  "linesRem": 6
}