{
  "files": 1, 
  "nb_test": 1803, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.jackrabbit.oak.plugins.index.IndexUpdateTest"
  ], 
  "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\nindex 2116cee2c9..75f0f3195c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/IndexUpdate.java\n@@ -19,6 +19,7 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n import static com.google.common.collect.Lists.newArrayList;\n import static com.google.common.collect.Lists.newArrayListWithCapacity;\n+import static org.apache.jackrabbit.oak.api.Type.BOOLEAN;\n import static org.apache.jackrabbit.oak.commons.PathUtils.concat;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.ASYNC_PROPERTY_NAME;\n import static org.apache.jackrabbit.oak.plugins.index.IndexConstants.ASYNC_REINDEX_VALUE;\n@@ -108,7 +109,7 @@ private IndexUpdate(IndexUpdate parent, String name) {\n     @Override\n     public void enter(NodeState before, NodeState after)\n             throws CommitFailedException {\n-        collectIndexEditors(builder.getChildNode(INDEX_DEFINITIONS_NAME));\n+        collectIndexEditors(builder.getChildNode(INDEX_DEFINITIONS_NAME), before);\n \n         // no-op when reindex is empty\n         CommitFailedException exception = EditorDiff.process(\n@@ -122,17 +123,30 @@ public void enter(NodeState before, NodeState after)\n         }\n     }\n \n-    private void collectIndexEditors(NodeBuilder definitions)\n-            throws CommitFailedException {\n+    private boolean shouldReindex(NodeBuilder definition, NodeState before,\n+            String name) {\n+        PropertyState ps = definition.getProperty(REINDEX_PROPERTY_NAME);\n+        if (ps != null && ps.getValue(BOOLEAN)) {\n+            return true;\n+        }\n+        // reindex in the case this is a new node, even though the reindex flag\n+        // might be set to 'false' (possible via content import)\n+        return !before.getChildNode(INDEX_DEFINITIONS_NAME).hasChildNode(name);\n+    }\n+\n+    private void collectIndexEditors(NodeBuilder definitions,\n+            NodeState before) throws CommitFailedException {\n         for (String name : definitions.getChildNodeNames()) {\n             NodeBuilder definition = definitions.getChildNode(name);\n             if (Objects.equal(async, definition.getString(ASYNC_PROPERTY_NAME))) {\n                 String type = definition.getString(TYPE_PROPERTY_NAME);\n+                boolean shouldReindex = shouldReindex(definition,\n+                        before, name);\n                 Editor editor = provider.getIndexEditor(type, definition, root, updateCallback);\n                 if (editor == null) {\n                     // trigger reindexing when an indexer becomes available\n                     definition.setProperty(REINDEX_PROPERTY_NAME, true);\n-                } else if (definition.getBoolean(REINDEX_PROPERTY_NAME)) {\n+                } else if (shouldReindex) {\n                     if (definition.getBoolean(REINDEX_ASYNC_PROPERTY_NAME)\n                             && definition.getString(ASYNC_PROPERTY_NAME) == null) {\n                         // switch index to an async update mode\n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 18, 
  "jira_id": "1874", 
  "nb_skipped": 9, 
  "commit": "3ae276c1", 
  "nb_failure": 1, 
  "linesRem": 4
}