{
  "files": 1, 
  "nb_test": 2982, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.jackrabbit.oak.plugins.document.ClusterInfoTest"
  ], 
  "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java\nindex 92208a1eb3..59d5f75ed4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ClusterNodeInfo.java\n@@ -374,7 +374,7 @@ public static ClusterNodeInfo getInstance(DocumentStore store, String machineId,\n \n         int retries = 10;\n         for (int i = 0; i < retries; i++) {\n-            ClusterNodeInfo clusterNode = createInstance(store, machineId, instanceId, configuredClusterId);\n+            ClusterNodeInfo clusterNode = createInstance(store, machineId, instanceId, configuredClusterId, i == 0);\n             String key = String.valueOf(clusterNode.id);\n             UpdateOp update = new UpdateOp(key, true);\n             update.set(ID, key);\n@@ -409,7 +409,7 @@ public static ClusterNodeInfo getInstance(DocumentStore store, String machineId,\n     }\n \n     private static ClusterNodeInfo createInstance(DocumentStore store, String machineId,\n-            String instanceId, int configuredClusterId) {\n+            String instanceId, int configuredClusterId, boolean waitForLease) {\n \n         long now = getCurrentTime();\n         int clusterNodeId = 0;\n@@ -447,16 +447,25 @@ private static ClusterNodeInfo createInstance(DocumentStore store, String machin\n             }\n \n             Long leaseEnd = (Long) doc.get(LEASE_END_KEY);\n+            String mId = \"\" + doc.get(MACHINE_ID_KEY);\n+            String iId = \"\" + doc.get(INSTANCE_ID_KEY);\n \n             if (leaseEnd != null && leaseEnd > now) {\n-                // TODO wait for lease end, see OAK-3449\n+                // wait if (a) instructed to, and (b) also the remaining time\n+                // time is not much bigger than the lease interval (in which\n+                // case something is very very wrong anyway)\n+                if (waitForLease && (leaseEnd - now) < (DEFAULT_LEASE_DURATION_MILLIS + 5000) && mId.equals(machineId)\n+                        && iId.equals(instanceId)) {\n+                    boolean worthRetrying = waitForLeaseExpiry(store, doc, leaseEnd.longValue(), machineId, instanceId);\n+                    if (worthRetrying) {\n+                        return createInstance(store, machineId, instanceId, configuredClusterId, false);\n+                    }\n+                }\n+\n                 reuseFailureReason = \"leaseEnd \" + leaseEnd + \" > \" + now + \" - \" + (leaseEnd - now) + \"ms in the future\";\n                 continue;\n             }\n \n-            String mId = \"\" + doc.get(MACHINE_ID_KEY);\n-            String iId = \"\" + doc.get(INSTANCE_ID_KEY);\n-\n             // remove entries with \"random:\" keys if not in use (no lease at all) \n             if (mId.startsWith(RANDOM_PREFIX) && leaseEnd == null) {\n                 store.remove(Collection.CLUSTER_NODES, key);\n@@ -506,6 +515,51 @@ private static ClusterNodeInfo createInstance(DocumentStore store, String machin\n                 RecoverLockState.NONE, prevLeaseEnd, newEntry);\n     }\n \n+    private static boolean waitForLeaseExpiry(DocumentStore store, ClusterNodeInfoDocument cdoc, long leaseEnd, String machineId,\n+            String instanceId) {\n+        String key = cdoc.getId();\n+        LOG.info(\"Found an existing possibly active cluster node info (\" + key + \") for this instance: \" + machineId + \"/\"\n+                + instanceId + \", will try use it.\");\n+\n+        // wait until lease expiry plus 2s\n+        long waitUntil = leaseEnd + 2000;\n+\n+        while (getCurrentTime() < waitUntil) {\n+            LOG.info(\"Waiting for cluster node \" + key + \"'s lease to expire: \" + (waitUntil - getCurrentTime()) / 1000 + \"s left\");\n+\n+            try {\n+                Thread.sleep(5000);\n+            } catch (InterruptedException e) {\n+                // ignored\n+            }\n+\n+            try {\n+                // check state of cluster node info\n+                ClusterNodeInfoDocument reread = store.find(Collection.CLUSTER_NODES, key);\n+                if (reread == null) {\n+                    LOG.info(\"Cluster node info \" + key + \": gone; continueing.\");\n+                    return true;\n+                } else {\n+                    Long newLeaseEnd = (Long) reread.get(LEASE_END_KEY);\n+                    if (newLeaseEnd == null) {\n+                        LOG.info(\"Cluster node \" + key + \": lease end information missing, aborting.\");\n+                        return false;\n+                    } else {\n+                        if (newLeaseEnd.longValue() != leaseEnd) {\n+                            LOG.info(\"Cluster node \" + key + \" seems to be still active (lease end changed from \" + leaseEnd\n+                                    + \" to \" + newLeaseEnd + \", will not try to use it.\");\n+                            return false;\n+                        }\n+                    }\n+                }\n+            } catch (DocumentStoreException ex) {\n+                LOG.info(\"Error reading cluster node info for key \" + key, ex);\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n     public void performLeaseCheck() {\n         if (leaseCheckDisabled || !renewed) {\n             // if leaseCheckDisabled is set we never do the check, so return fast\n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 60, 
  "jira_id": "3424", 
  "nb_skipped": 1, 
  "commit": "f4349a96", 
  "nb_failure": 1, 
  "linesRem": 6
}