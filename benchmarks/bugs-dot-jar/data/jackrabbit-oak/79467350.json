{
  "files": 3, 
  "nb_test": 1461, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.jackrabbit.oak.query.index.TraversingIndexQueryTest", 
    "org.apache.jackrabbit.oak.query.index.FilterTest"
  ], 
  "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\nindex 75e48bc7e2..26a3a43800 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/ast/ComparisonImpl.java\n@@ -118,7 +118,7 @@ private boolean evaluate(PropertyValue p1, PropertyValue p2) {\n         case EQUAL:\n             return PropertyValues.match(p1, p2);\n         case NOT_EQUAL:\n-            return !PropertyValues.match(p1, p2);\n+            return PropertyValues.notMatch(p1, p2);\n         case GREATER_OR_EQUAL:\n             return p1.compareTo(p2) >= 0;\n         case GREATER_THAN:\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\nindex 6eb282ee9b..b31e74034c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/query/index/FilterImpl.java\n@@ -252,16 +252,17 @@ public void restrictProperty(String propertyName, Operator op, PropertyValue v)\n         switch (op) {\n         case EQUAL:\n             if (x.first != null && x.last == x.first && x.firstIncluding && x.lastIncluding) {\n-                // there is already an equality condition on this property\n-                // we will keep this, as it could be a multi-valued property\n-                // (unlike in databases, \"x = 1 and x = 2\" can match a node\n-                // if x is a multi-valued property with value \"{1, 2}\")\n-                return;\n+                // we keep the old equality condition if there is one;\n+                // we can not use setAlwaysFalse, as this would not be correct\n+                // for multi-valued properties:\n+                // unlike in databases, \"x = 1 and x = 2\" can match a node\n+                // if x is a multi-valued property with value {1, 2}\n+            } else {\n+                // all other conditions (range conditions) are replaced with this one\n+                // (we can not use setAlwaysFalse for the same reason as above)\n+                x.first = x.last = v;\n+                x.firstIncluding = x.lastIncluding = true;\n             }\n-            x.first = maxValue(oldFirst, v);\n-            x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n-            x.last = minValue(oldLast, v);\n-            x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\n             break;\n         case NOT_EQUAL:\n             if (v != null) {\n@@ -269,25 +270,40 @@ public void restrictProperty(String propertyName, Operator op, PropertyValue v)\n             }\n             break;\n         case GREATER_THAN:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.first == null) {\n                 x.first = maxValue(oldFirst, v);\n                 x.firstIncluding = false;\n+            }\n             break;\n         case GREATER_OR_EQUAL:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.first == null) {\n                 x.first = maxValue(oldFirst, v);\n                 x.firstIncluding = x.first == oldFirst ? x.firstIncluding : true;\n+            }\n             break;\n         case LESS_THAN:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.last == null) {\n                 x.last = minValue(oldLast, v);\n                 x.lastIncluding = false;\n+            }\n             break;\n         case LESS_OR_EQUAL:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.last == null) {\n                 x.last = minValue(oldLast, v);\n                 x.lastIncluding = x.last == oldLast ? x.lastIncluding : true;\n+            }\n             break;\n         case LIKE:\n+            // we don't narrow the range because of multi-valued properties\n+            if (x.first == null) {\n                 // LIKE is handled in the fulltext index\n                 x.isLike = true;\n                 x.first = v;\n+            }\n             break;\n         case IN:\n             \ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java\nindex 67e9cdb133..5320a4fc91 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/PropertyValues.java\n@@ -167,7 +167,7 @@ public static boolean match(PropertyValue p1, PropertyValue p2) {\n             }\n             if (!p1.isArray() && p2.isArray()) {\n                 return contains(p2.getValue(Type.BINARIES),\n-                        p2.getValue(Type.BINARY));\n+                        p1.getValue(Type.BINARY));\n             }\n             break;\n         default:\n@@ -185,6 +185,53 @@ public static boolean match(PropertyValue p1, PropertyValue p2) {\n \n     }\n \n+    public static boolean notMatch(PropertyValue p1, PropertyValue p2) {\n+        if (p1.getType().tag() != p2.getType().tag()) {\n+            return true;\n+        }\n+\n+        switch (p1.getType().tag()) {\n+        case PropertyType.BINARY:\n+            if (p1.isArray() && !p2.isArray()) {\n+                if (p1.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p1.getValue(Type.BINARIES),\n+                        p2.getValue(Type.BINARY));\n+            }\n+            if (!p1.isArray() && p2.isArray()) {\n+                if (p2.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p2.getValue(Type.BINARIES),\n+                        p1.getValue(Type.BINARY));\n+            }\n+            break;\n+        default:\n+            if (p1.isArray() && !p2.isArray()) {\n+                if (p1.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p1.getValue(Type.STRINGS),\n+                        p2.getValue(Type.STRING));\n+            }\n+            if (!p1.isArray() && p2.isArray()) {\n+                if (p2.count() > 1) {\n+                    // a value can not possibly match multiple distinct values\n+                    return true;\n+                }\n+                return !contains(p2.getValue(Type.STRINGS),\n+                        p1.getValue(Type.STRING));\n+            }\n+        }\n+        // both arrays or both single values\n+        return p1.compareTo(p2) != 0;\n+\n+    }\n+\n     // --\n \n     /**\n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 74, 
  "jira_id": "1075", 
  "nb_skipped": 6, 
  "commit": "79467350", 
  "nb_failure": 4, 
  "linesRem": 11
}