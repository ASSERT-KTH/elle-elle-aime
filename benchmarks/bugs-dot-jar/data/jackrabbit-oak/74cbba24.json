{
  "files": 2, 
  "nb_test": 2886, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.jackrabbit.oak.plugins.document.NodeDocumentTest"
  ], 
  "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\nindex cdff3e131c..e36d1adffa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/NodeDocument.java\n@@ -19,6 +19,7 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.Map;\n import java.util.Map.Entry;\n import java.util.NavigableMap;\n@@ -39,6 +40,7 @@\n import com.google.common.collect.AbstractIterator;\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.Iterators;\n+import com.google.common.collect.Lists;\n import com.google.common.collect.Queues;\n import org.apache.jackrabbit.oak.cache.CacheValue;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n@@ -54,7 +56,6 @@\n import com.google.common.collect.Iterables;\n import com.google.common.collect.Maps;\n import com.google.common.collect.Sets;\n-import com.google.common.primitives.Longs;\n \n import static com.google.common.base.Objects.equal;\n import static com.google.common.base.Preconditions.checkArgument;\n@@ -65,6 +66,7 @@\n import static org.apache.jackrabbit.oak.plugins.document.StableRevisionComparator.REVERSE;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Key;\n import static org.apache.jackrabbit.oak.plugins.document.UpdateOp.Operation;\n+import static org.apache.jackrabbit.oak.plugins.document.util.Utils.abortingIterable;\n import static org.apache.jackrabbit.oak.plugins.document.util.Utils.resolveCommitRevision;\n \n /**\n@@ -759,18 +761,24 @@ Revision getNewestRevision(final RevisionContext context,\n         }\n         // if we don't have clusterIds, we can use the local changes only\n         boolean fullScan = true;\n-        Iterable<Revision> changes;\n-        if (clusterIds.isEmpty()) {\n-            // baseRev is newer than all previous documents\n-            changes = Iterables.mergeSorted(\n+        Iterable<Revision> changes = Iterables.mergeSorted(\n                 ImmutableList.of(\n                         getLocalRevisions().keySet(),\n                         getLocalCommitRoot().keySet()),\n-                    getLocalRevisions().comparator());\n-        } else {\n+                getLocalRevisions().comparator()\n+        );\n+        if (!clusterIds.isEmpty()) {\n+            // there are some previous documents that potentially\n+            // contain changes after 'lower' revision vector\n             // include previous documents as well (only needed in rare cases)\n             fullScan = false;\n-            changes = getAllChanges();\n+            changes = Iterables.mergeSorted(\n+                    ImmutableList.of(\n+                            changes,\n+                            getChanges(REVISIONS, lower),\n+                            getChanges(COMMIT_ROOT, lower)\n+                    ), getLocalRevisions().comparator()\n+            );\n             if (LOG.isDebugEnabled()) {\n                 LOG.debug(\"getNewestRevision() with changeRev {} on {}, \" +\n                                 \"_revisions {}, _commitRoot {}\",\n@@ -1453,90 +1461,18 @@ NodeDocument findPrevReferencingDoc(Revision revision, int height) {\n      * @return revisions of all changes performed on this document.\n      */\n     Iterable<Revision> getAllChanges() {\n-        final SortedSet<Revision> stack = Sets.newTreeSet(REVERSE);\n-        // initialize with local revisions and commitRoot entries\n-        stack.addAll(getLocalCommitRoot().keySet());\n-        stack.addAll(getLocalRevisions().keySet());\n-        if (getPreviousRanges().isEmpty()) {\n-            return stack;\n-        }\n-        return new Iterable<Revision>() {\n-            @Override\n-            public Iterator<Revision> iterator() {\n-                final Iterator<NodeDocument> previousDocs = getPreviousDocLeaves();\n-                return new AbstractIterator<Revision>() {\n-                    private NodeDocument nextDoc;\n-                    private Revision nextRevision;\n-                    @Override\n-                    protected Revision computeNext() {\n-                        if (stack.isEmpty()) {\n-                            return endOfData();\n-                        }\n-                        Revision next = stack.first();\n-                        stack.remove(next);\n-                        fillStackIfNeeded();\n-                        return next;\n-                    }\n-\n-                    private void fillStackIfNeeded() {\n-                        for (;;) {\n-                            fetchNextDoc();\n-\n-                            // no more changes to compare with\n-                            if (nextDoc == null) {\n-                                return;\n-                            }\n-\n-                            // check if current top revision is still newer than\n-                            // most recent revision of next document\n-                            if (!stack.isEmpty()) {\n-                                Revision top = stack.first();\n-                                if (top.compareRevisionTimeThenClusterId(nextRevision) > 0) {\n-                                    return;\n-                                }\n-                            }\n-\n-                            // if we get here, we need to pull in changes\n-                            // from nextDoc\n-                            Iterables.addAll(stack, nextDoc.getAllChanges());\n-                            nextDoc = null;\n-                            nextRevision = null;\n-                        }\n-                    }\n-\n-                    /**\n-                     * Fetch the next document if {@code nextDoc} is\n-                     * {@code null} and there are more documents.\n-                     */\n-                    private void fetchNextDoc() {\n-                        for (;;) {\n-                            if (nextDoc != null) {\n-                                break;\n-                            }\n-                            if (!previousDocs.hasNext()) {\n-                                // no more previous docs\n-                                break;\n-                            }\n-                            nextDoc = previousDocs.next();\n-                            Iterator<Revision> changes = nextDoc.getAllChanges().iterator();\n-                            if (changes.hasNext()) {\n-                                nextRevision = changes.next();\n-                                break;\n-                            } else {\n-                                // empty document, try next\n-                                nextDoc = null;\n-                            }\n-                        }\n-                    }\n-                };\n-            }\n-        };\n+        RevisionVector empty = new RevisionVector();\n+        return Iterables.mergeSorted(ImmutableList.of(\n+                getChanges(REVISIONS, empty),\n+                getChanges(COMMIT_ROOT, empty)\n+        ), StableRevisionComparator.REVERSE);\n     }\n \n     /**\n      * Returns all changes for the given property back to {@code min} revision\n      * (exclusive). The revisions include committed as well as uncommitted\n-     * changes.\n+     * changes. The returned revisions are sorted in reverse order (newest\n+     * first).\n      *\n      * @param property the name of the property.\n      * @param min the lower bound revision (exclusive).\n@@ -1545,43 +1481,27 @@ private void fetchNextDoc() {\n     @Nonnull\n     Iterable<Revision> getChanges(@Nonnull final String property,\n                                   @Nonnull final RevisionVector min) {\n-        return new Iterable<Revision>() {\n-            @Override\n-            public Iterator<Revision> iterator() {\n-                final Set<Revision> changes = getValueMap(property).keySet();\n-                final Set<Integer> clusterIds = Sets.newHashSet();\n-                for (Revision r : getLocalMap(property).keySet()) {\n-                    clusterIds.add(r.getClusterId());\n-                }\n-                for (Range r : getPreviousRanges().values()) {\n-                    if (min.isRevisionNewer(r.high)) {\n-                        clusterIds.add(r.high.getClusterId());\n-                    }\n-                }\n-                final Iterator<Revision> unfiltered = changes.iterator();\n-                return new AbstractIterator<Revision>() {\n+        Predicate<Revision> p = new Predicate<Revision>() {\n             @Override\n-                    protected Revision computeNext() {\n-                        while (unfiltered.hasNext()) {\n-                            Revision next = unfiltered.next();\n-                            if (min.isRevisionNewer(next)) {\n-                                return next;\n-                            } else {\n-                                // further revisions with this clusterId\n-                                // are older than min revision\n-                                clusterIds.remove(next.getClusterId());\n-                                // no more revisions to check\n-                                if (clusterIds.isEmpty()) {\n-                                    return endOfData();\n+            public boolean apply(Revision input) {\n+                return min.isRevisionNewer(input);\n             }\n+        };\n+        List<Iterable<Revision>> changes = Lists.newArrayList();\n+        changes.add(abortingIterable(getLocalMap(property).keySet(), p));\n+        for (Map.Entry<Revision, Range> e : getPreviousRanges().entrySet()) {\n+            if (min.isRevisionNewer(e.getKey())) {\n+                final NodeDocument prev = getPreviousDoc(e.getKey(), e.getValue());\n+                if (prev != null) {\n+                    changes.add(abortingIterable(prev.getValueMap(property).keySet(), p));\n                 }\n             }\n-                        return endOfData();\n         }\n-                };\n+        if (changes.size() == 1) {\n+            return changes.get(0);\n+        } else {\n+            return Iterables.mergeSorted(changes, StableRevisionComparator.REVERSE);\n         }\n-        };\n-\n     }\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java\nindex c7a4253749..40ad9bbbab 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/util/Utils.java\n@@ -758,4 +758,36 @@ public static long getMinTimestampForDiff(@Nonnull RevisionVector fromRev,\n         }\n         return min;\n     }\n+\n+    /**\n+     * Wraps the given iterable and aborts iteration over elements when the\n+     * predicate on an element evaluates to {@code false}.\n+     *\n+     * @param iterable the iterable to wrap.\n+     * @param p the predicate.\n+     * @return the aborting iterable.\n+     */\n+    public static <T> Iterable<T> abortingIterable(final Iterable<T> iterable,\n+                                                   final Predicate<T> p) {\n+        checkNotNull(iterable);\n+        checkNotNull(p);\n+        return new Iterable<T>() {\n+            @Override\n+            public Iterator<T> iterator() {\n+                final Iterator<T> it = iterable.iterator();\n+                return new AbstractIterator<T>() {\n+                    @Override\n+                    protected T computeNext() {\n+                        if (it.hasNext()) {\n+                            T next = it.next();\n+                            if (p.apply(next)) {\n+                                return next;\n+                            }\n+                        }\n+                        return endOfData();\n+                    }\n+                };\n+            }\n+        };\n+    }\n }\n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 70, 
  "jira_id": "4358", 
  "nb_skipped": 1, 
  "commit": "74cbba24", 
  "nb_failure": 1, 
  "linesRem": 118
}