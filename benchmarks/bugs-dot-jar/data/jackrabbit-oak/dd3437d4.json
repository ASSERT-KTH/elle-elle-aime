{
  "files": 1, 
  "nb_test": 1805, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.jackrabbit.oak.plugins.document.RevisionTest"
  ], 
  "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\nindex 9265368c42..be45ba33b3 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/Revision.java\n@@ -549,6 +549,9 @@ public int compare(Revision o1, Revision o2) {\n          * <ul>\n          *     <li>\n          *         {@code null} if the revision is older than the earliest range\n+         *         and the revision timestamp is less than or equal the time\n+         *         of the last {@link #purge(long)} (see also\n+         *         {@link #oldestTimestamp}).\n          *     </li>\n          *     <li>\n          *         if the revision is newer than the lower bound of the newest\n@@ -565,9 +568,49 @@ public int compare(Revision o1, Revision o2) {\n          *     </li>\n          * </ul>\n          *\n+         * Below is a graph for a revision comparison example as seen from one\n+         * cluster node with some known revision ranges. Revision ranges less\n+         * than or equal r2-0-0 have been purged and there are known ranges for\n+         * cluster node 1 (this cluster node) and cluster node 2 (some other\n+         * cluster node).\n+         * <pre>\n+         *     View from cluster node 1:\n+         *\n+         *                purge    r3-0-1    r5-0-2    r7-0-1\n+         *                  \u02c5         \u02c5         \u02c5         \u02c5\n+         *     ---+---------+---------+---------+---------+---------\n+         *     r1-0-0    r2-0-0    r3-0-0    r4-0-0    r5-0-0\n+         *\n+         *            ^\n+         *         r1-0-1 -> null (1)\n+         *\n+         *                      ^\n+         *                   r4-0-2 -> r4-0-0 (2)\n+         *\n+         *                            ^\n+         *                         r3-0-1 -> r3-0-0 (3)\n+         *\n+         *                                           ^\n+         *                                        r6-0-2 -> FUTURE (4)\n+         *\n+         *                                                       ^\n+         *                                                    r9-0-1 -> NEWEST (5)\n+         * </pre>\n+         * <ol>\n+         *     <li>older than earliest range and purge time</li>\n+         *     <li>seen-at of next higher range</li>\n+         *     <li>seen-at of matching lower bound of range</li>\n+         *     <li>foreign revision is newer than most recent range</li>\n+         *     <li>local revision is newer than most recent range</li>\n+         * </ol>\n+         * This gives the following revision ordering:\n+         * <pre>\n+         * r1-0-1 < r3-0-1 < r-4-0-2 < r9-0-1 < r6-0-2\n+         * </pre>\n+         *\n          * @param r the revision\n          * @return the seen-at revision or {@code null} if the revision is older\n-         *          than the earliest range.\n+         *          than the earliest range and purge time.\n          */\n         Revision getRevisionSeen(Revision r) {\n             List<RevisionRange> list = map.get(r.getClusterId());\n@@ -586,8 +629,9 @@ Revision getRevisionSeen(Revision r) {\n             // search from latest backward\n             // (binary search could be used, but we expect most queries\n             // at the end of the list)\n+            RevisionRange range = null;\n             for (int i = list.size() - 1; i >= 0; i--) {\n-                RevisionRange range = list.get(i);\n+                range = list.get(i);\n                 int compare = r.compareRevisionTime(range.revision);\n                 if (compare == 0) {\n                     return range.seenAt;\n@@ -597,15 +641,21 @@ Revision getRevisionSeen(Revision r) {\n                         if (r.getClusterId() == currentClusterNodeId) {\n                             // newer than all others, except for FUTURE\n                             return NEWEST;\n-                        }\n+                        } else {\n                             // happens in the future (not visible yet)\n                             return FUTURE;\n+                        }\n                     } else {\n                         // there is a newer range\n                         return list.get(i + 1).seenAt;\n                     }\n                 }\n             }\n+            if (range != null && r.getTimestamp() > oldestTimestamp) {\n+                // revision is older than earliest range and after purge\n+                // timestamp. return seen-at revision of earliest range.\n+                return range.seenAt;\n+            }\n             return null;\n         }\n \n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 53, 
  "jira_id": "1788", 
  "nb_skipped": 9, 
  "commit": "dd3437d4", 
  "nb_failure": 3, 
  "linesRem": 3
}