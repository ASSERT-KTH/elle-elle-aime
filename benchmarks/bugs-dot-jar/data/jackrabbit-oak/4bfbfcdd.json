{
  "files": 9, 
  "nb_test": 1899, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexTest"
  ], 
  "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\nindex 74cfd81f6f..0574916b5a 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndex.java\n@@ -44,6 +44,7 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(OrderedPropertyIndex.class);\n \n+    @Override\n     public String getIndexName() {\n         return TYPE;\n     }\n@@ -57,6 +58,7 @@ OrderedPropertyIndexLookup getLookup(NodeState root) {\n      * \n      * !!! for now we want to skip the use-case of NON range-queries !!!\n      */\n+    @Override\n     public double getCost(Filter filter, NodeState root) {\n         throw new UnsupportedOperationException(\"Not supported as implementing AdvancedQueryIndex\");\n     }\n@@ -181,6 +183,7 @@ public Cursor query(IndexPlan plan, NodeState root) {\n \n         Filter filter = plan.getFilter();\n         List<OrderEntry> sortOrder = plan.getSortOrder();\n+        String pathPrefix = plan.getPathPrefix();\n         Iterable<String> paths = null;\n         OrderedContentMirrorStoreStrategy strategy\n                 = OrderedPropertyIndexLookup.getStrategy(plan.getDefinition());\n@@ -190,7 +193,7 @@ public Cursor query(IndexPlan plan, NodeState root) {\n             String propertyName = PathUtils.getName(pr.propertyName);\n             depth = PathUtils.getDepth(propertyName);\n             paths = strategy.query(plan.getFilter(), propertyName,\n-                    plan.getDefinition(), pr);\n+                    plan.getDefinition(), pr, pathPrefix);\n         }\n         if (paths == null && sortOrder != null && !sortOrder.isEmpty()) {\n             // we could be here if we have a query where the ORDER BY makes us play it.\n@@ -198,7 +201,7 @@ public Cursor query(IndexPlan plan, NodeState root) {\n                 String propertyName = PathUtils.getName(oe.getPropertyName());\n                 depth = PathUtils.getDepth(oe.getPropertyName());\n                 paths = strategy.query(plan.getFilter(), propertyName,\n-                        plan.getDefinition(), new PropertyRestriction());\n+                        plan.getDefinition(), new PropertyRestriction(), pathPrefix);\n             }\n         }\n \n@@ -209,7 +212,6 @@ public Cursor query(IndexPlan plan, NodeState root) {\n                             + filter);\n         }\n         Cursor cursor = Cursors.newPathCursor(paths, filter.getQueryEngineSettings());\n-        cursor = Cursors.newPrefixCursor(cursor, plan.getPathPrefix());\n         if (depth > 1) {\n             cursor = Cursors.newAncestorCursor(cursor, depth - 1, filter.getQueryEngineSettings());\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java\nindex df940110ee..dc35da41a0 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/OrderedPropertyIndexLookup.java\n@@ -203,7 +203,8 @@ public double getCost(Filter filter, String propertyName, PropertyValue value) {\n         if (indexMeta == null) {\n             throw new IllegalArgumentException(\"No index for \" + propertyName);\n         }\n-        return getStrategy(indexMeta).query(filter, propertyName, indexMeta, pr);\n+        return getStrategy(indexMeta).query(\n+                filter, propertyName, indexMeta, pr, \"\");\n     }\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java\nindex ae18d9bc55..cfd96e21d6 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexLookup.java\n@@ -129,7 +129,7 @@ public double getCost(Filter filter, String propertyName, PropertyValue value) {\n             return Double.POSITIVE_INFINITY;\n         }\n         return COST_OVERHEAD +\n-                getStrategy(indexMeta).count(indexMeta, encode(value), MAX_COST);\n+                getStrategy(indexMeta).count(filter, indexMeta, encode(value), MAX_COST);\n     }\n \n     /**\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\nindex 5cc398d074..8ace776a4e 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndexPlan.java\n@@ -135,7 +135,7 @@\n \n                 if (restriction != null) {\n                     Set<String> values = getValues(restriction);\n-                    double cost = strategy.count(definition, values, MAX_COST);\n+                    double cost = strategy.count(filter, definition, values, MAX_COST);\n                     if (cost < bestCost) {\n                         bestDepth = depth;\n                         bestValues = values;\n@@ -152,7 +152,7 @@\n                 if (constraint instanceof OrImpl) {\n                     Set<String> values = findMultiProperty((OrImpl) constraint);\n                     if (values != null) {\n-                        double cost = strategy.count(definition, values, MAX_COST);\n+                        double cost = strategy.count(filter, definition, values, MAX_COST);\n                         if (cost < bestCost) {\n                             bestDepth = 1;\n                             bestValues = values;\n@@ -208,7 +208,7 @@ private boolean isIndexed(DynamicOperandImpl operand) {\n         }\n     }\n \n-    private Set<String> getValues(PropertyRestriction restriction) {\n+    private static Set<String> getValues(PropertyRestriction restriction) {\n         if (restriction.firstIncluding\n                 && restriction.lastIncluding\n                 && restriction.first != null\n@@ -249,6 +249,7 @@ Cursor execute() {\n \n     //------------------------------------------------------------< Object >--\n \n+    @Override\n     public String toString() {\n         StringBuilder buffer = new StringBuilder(\"property \");\n         buffer.append(name);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\nindex be32205219..26eed1e0f8 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/ContentMirrorStoreStrategy.java\n@@ -121,7 +121,7 @@ private void insert(NodeBuilder index, String key, String value) {\n         return new Iterable<String>() {\n             @Override\n             public Iterator<String> iterator() {\n-                PathIterator it = new PathIterator(filter, indexName);\n+                PathIterator it = new PathIterator(filter, indexName, \"\");\n                 if (values == null) {\n                     it.setPathContainsValue(true);\n                     it.enqueue(getChildNodeEntries(index).iterator());\n@@ -157,8 +157,18 @@ public long count(NodeState indexMeta, Set<String> values, int max) {\n         return count(indexMeta, INDEX_CONTENT_NODE_NAME, values, max);\n     }\n \n+    @Override\n+    public long count(final Filter filter, NodeState indexMeta, Set<String> values, int max) {\n+        return count(filter, indexMeta, INDEX_CONTENT_NODE_NAME, values, max);\n+    }\n+\n     public long count(NodeState indexMeta, final String indexStorageNodeName,\n             Set<String> values, int max) {\n+        return count(null, indexMeta, indexStorageNodeName, values, max);\n+    }\n+\n+    public long count(Filter filter, NodeState indexMeta, final String indexStorageNodeName,\n+            Set<String> values, int max) {\n         NodeState index = indexMeta.getChildNode(indexStorageNodeName);\n         int count = 0;\n         if (values == null) {\n@@ -196,6 +206,11 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n             }\n             max = Math.max(10, max / size);\n             int i = 0;\n+            String filterRootPath = null;\n+            if (filter != null &&\n+                    filter.getPathRestriction().equals(Filter.PathRestriction.ALL_CHILDREN)) {\n+                filterRootPath = filter.getPath();\n+            }\n             for (String p : values) {\n                 if (count > max && i > 3) {\n                     // the total count is extrapolated from the the number \n@@ -204,6 +219,16 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n                     break;\n                 }\n                 NodeState s = index.getChildNode(p);\n+                if (filterRootPath != null && s.exists()) {\n+                    // Descend directly to path restriction inside index tree\n+                    for (String pathFragment : PathUtils\n+                            .elements(filterRootPath)) {\n+                        s = s.getChildNode(pathFragment);\n+                        if (!s.exists()) {\n+                            break;\n+                        }\n+                    }\n+                }\n                 if (s.exists()) {\n                     CountingNodeVisitor v = new CountingNodeVisitor(max);\n                     v.visit(s);\n@@ -227,6 +252,8 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n         private int readCount;\n         private boolean init;\n         private boolean closed;\n+        private String filterPath;\n+        private String pathPrefix;\n         private String parentPath;\n         private String currentPath;\n         private boolean pathContainsValue;\n@@ -237,9 +264,19 @@ public long count(NodeState indexMeta, final String indexStorageNodeName,\n         private final Set<String> knownPaths = Sets.newHashSet();\n         private final long maxMemoryEntries;\n \n-        PathIterator(Filter filter, String indexName) {\n+        PathIterator(Filter filter, String indexName, String pathPrefix) {\n             this.filter = filter;\n+            this.pathPrefix = pathPrefix;\n             this.indexName = indexName;\n+            boolean shouldDescendDirectly = filter.getPathRestriction().equals(Filter.PathRestriction.ALL_CHILDREN);\n+            if (shouldDescendDirectly) {            \n+                filterPath = filter.getPath();\n+                if (PathUtils.denotesRoot(filterPath)) {\n+                    filterPath = \"\";\n+                }\n+            } else {\n+                filterPath = \"\";\n+            }            \n             parentPath = \"\";\n             currentPath = \"/\";\n             this.maxMemoryEntries = filter.getQueryEngineSettings().getLimitInMemory();\n@@ -305,6 +342,25 @@ private void fetchNextPossiblyDuplicate() {\n                     }\n                     currentPath = PathUtils.concat(parentPath, name);\n \n+                    if (!\"\".equals(filterPath)) {\n+                        String p = currentPath;\n+                        if (pathContainsValue) {\n+                            String value = PathUtils.elements(p).iterator().next();\n+                            p = PathUtils.relativize(value, p);                        \n+                        }\n+                        if (\"\".equals(pathPrefix)) {\n+                            p = PathUtils.concat(\"/\", p);\n+                        } else {\n+                            p = PathUtils.concat(pathPrefix, p);\n+                        }\n+                        if (!\"\".equals(p) && \n+                                !p.equals(filterPath) && \n+                                !PathUtils.isAncestor(p, filterPath) && \n+                                !PathUtils.isAncestor(filterPath, p)) {\n+                            continue;\n+                        }\n+                    }\n+\n                     nodeIterators.addLast(node.getChildNodeEntries().iterator());\n                     parentPath = currentPath;\n \n@@ -330,7 +386,7 @@ public String next() {\n                 fetchNext();\n                 init = true;\n             }\n-            String result = currentPath;\n+            String result = PathUtils.concat(pathPrefix, currentPath);\n             fetchNext();\n             return result;\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java\nindex 5864eef052..6438fc0062 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/IndexStoreStrategy.java\n@@ -43,7 +43,7 @@ void update(\n     /**\n      * Search for a given set of values.\n      * \n-     * @param filter the filter (used for logging)\n+     * @param filter the filter (can optionally be used for optimized query execution)\n      * @param indexName the name of the index (for logging)\n      * @param indexMeta the index metadata node (may not be null)\n      * @param values values to look for (null to check for property existence)\n@@ -62,4 +62,16 @@ void update(\n      */\n     long count(NodeState indexMeta, Set<String> values, int max);\n \n+    /**\n+     * Count the occurrence of a given set of values. Used in calculating the\n+     * cost of an index.\n+     *\n+     * @param filter the filter which can be used to estimate better cost\n+     * @param indexMeta the index metadata node (may not be null)\n+     * @param values values to look for (null to check for property existence)\n+     * @param max the maximum value to return\n+     * @return the aggregated count of occurrences for each provided value\n+     */\n+    long count(Filter filter, NodeState indexMeta, Set<String> values, int max);\n+\n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\nindex 2445869ebe..411f734c33 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/OrderedContentMirrorStoreStrategy.java\n@@ -265,6 +265,11 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n         return cne;\n     }\n     \n+    public Iterable<String> query(final Filter filter, final String indexName,\n+            final NodeState indexMeta, final PropertyRestriction pr) {\n+        return query(filter, indexName, indexMeta, pr, \"\");\n+    }\n+\n     /**\n      * search the index for the provided PropertyRestriction\n      * \n@@ -275,8 +280,9 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n      * @return the iterable\n      */\n     public Iterable<String> query(final Filter filter, final String indexName,\n-                                  final NodeState indexMeta, final PropertyRestriction pr) {\n-        return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr);\n+                                  final NodeState indexMeta, final PropertyRestriction pr,\n+                                  String pathPrefix) {\n+        return query(filter, indexName, indexMeta, INDEX_CONTENT_NODE_NAME, pr, pathPrefix);\n     }\n \n     /**\n@@ -292,7 +298,7 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n      */\n     public Iterable<String> query(final Filter filter, final String indexName,\n                                   final NodeState indexMeta, final String indexStorageNodeName,\n-                                  final PropertyRestriction pr) {\n+                                  final PropertyRestriction pr, String pathPrefix) {\n         if (LOG.isDebugEnabled()) {\n             LOG.debug(\"query() - filter: {}\", filter);            \n             LOG.debug(\"query() - indexName: {}\", indexName);            \n@@ -325,11 +331,14 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n                         indexState.getChildNode(firstValuableItemKey));\n                     if (direction.isAscending()) {\n                         childrenIterable = new SeekedIterable(indexState, firstValueableItem);\n-                        it = new QueryResultsWrapper(filter, indexName, childrenIterable);\n+                        it = new QueryResultsWrapper(filter, indexName, \n+                                childrenIterable, pathPrefix);\n                     } else {\n-                        it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(\n+                        it = new QueryResultsWrapper(filter, indexName, \n+                                new BetweenIterable(\n                                         indexState, firstValueableItem, firstEncoded,\n-                            pr.firstIncluding, direction));\n+                                        pr.firstIncluding, direction),\n+                                pathPrefix);\n                     }\n                 }\n             } else {\n@@ -362,7 +371,8 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n                         indexState.getChildNode(firstValuableItemKey));\n                     childrenIterable = new BetweenIterable(indexState, firstValueableItem, last,\n                         includeLast, direction);\n-                    it = new QueryResultsWrapper(filter, indexName, childrenIterable);\n+                    it = new QueryResultsWrapper(filter, indexName, \n+                            childrenIterable, pathPrefix);\n                 }\n             }\n \n@@ -387,18 +397,21 @@ void prune(final NodeBuilder index, final Deque<NodeBuilder> builders, final Str\n                 firstValueableItem = new OrderedChildNodeEntry(firstValueableItemKey,\n                     indexState.getChildNode(firstValueableItemKey));\n                 if (direction.isAscending()) {\n-                    it = new QueryResultsWrapper(filter, indexName, new BetweenIterable(indexState,\n-                        firstValueableItem, searchfor, include, direction));\n+                    it = new QueryResultsWrapper(filter, indexName, \n+                            new BetweenIterable(indexState, firstValueableItem, searchfor, include, direction),\n+                            pathPrefix);\n                 } else {\n-                    it = new QueryResultsWrapper(filter, indexName, new SeekedIterable(indexState,\n-                        firstValueableItem));\n+                    it = new QueryResultsWrapper(filter, indexName, \n+                            new SeekedIterable(indexState, firstValueableItem),\n+                            pathPrefix);\n                 }\n             }\n             return it;\n         } else {\n             // property is not null. AKA \"open query\"\n             LOG.debug(\"property is not null. AKA 'open query'. FullIterable\");\n-            return new QueryResultsWrapper(filter, indexName, new FullIterable(indexState, false));\n+            return new QueryResultsWrapper(filter, indexName, \n+                    new FullIterable(indexState, false), pathPrefix);\n         }\n     }\n     \n@@ -602,17 +615,20 @@ public String getSearchFor() {\n         private Iterable<ChildNodeEntry> children;\n         private String indexName;\n         private Filter filter;\n+        private String pathPrefix;\n \n         public QueryResultsWrapper(Filter filter, String indexName,\n-                                   Iterable<ChildNodeEntry> children) {\n+                                   Iterable<ChildNodeEntry> children,\n+                                   String pathPrefix) {\n             this.children = children;\n             this.indexName = indexName;\n             this.filter = filter;\n+            this.pathPrefix = pathPrefix;\n         }\n \n         @Override\n         public Iterator<String> iterator() {\n-            PathIterator pi = new PathIterator(filter, indexName);\n+            PathIterator pi = new PathIterator(filter, indexName, pathPrefix);\n             pi.setPathContainsValue(true);\n             pi.enqueue(children.iterator());\n             return pi;\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java\nindex 15111ec0a4..ca80c7e22c 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/strategy/UniqueEntryStoreStrategy.java\n@@ -166,4 +166,8 @@ public long count(NodeState indexMeta, Set<String> values, int max) {\n         return count;\n     }\n \n+    @Override\n+    public long count(final Filter filter, NodeState indexMeta, Set<String> values, int max) {\n+        return count(indexMeta, values, max);\n+    }\n }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\nindex 4d851910c8..ff4a1abfb7 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/spi/query/Cursors.java\n@@ -24,7 +24,6 @@\n \n import javax.annotation.Nullable;\n \n-import org.apache.jackrabbit.oak.api.PropertyValue;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.apache.jackrabbit.oak.plugins.memory.MemoryChildNodeEntry;\n import org.apache.jackrabbit.oak.query.FilterIterators;\n@@ -73,23 +72,6 @@ public static Cursor newPathCursor(Iterable<String> paths, QueryEngineSettings s\n         return new PathCursor(paths.iterator(), true, settings);\n     }\n \n-    /**\n-     * Creates a cursor which wraps another cursor and adds a path prefix to\n-     * each of row of the wrapped cursor. This method will return the passed\n-     * cursor as is if {@code path} is the empty string or the root path (\"/\").\n-     *\n-     * @param c    the cursor to wrap.\n-     * @param path the path prefix.\n-     * @return the cursor.\n-     */\n-    public static Cursor newPrefixCursor(Cursor c, String path) {\n-        if (path.isEmpty() || PathUtils.denotesRoot(path)) {\n-            // no need to wrap\n-            return c;\n-        }\n-        return new PrefixCursor(c, path);\n-    }\n-    \n     /**\n      * Creates a {@link Cursor} over paths, and make the result distinct.\n      * The iterator might return duplicate paths\n@@ -219,48 +201,6 @@ public boolean hasNext() {\n         \n     }\n \n-    /**\n-     * A cursor which wraps another cursor and adds a path prefix to each of\n-     * row of the wrapped cursor.\n-     */\n-    private static final class PrefixCursor extends AbstractCursor {\n-\n-        private final Cursor c;\n-        private final String path;\n-\n-        PrefixCursor(Cursor c, String prefix) {\n-            this.c = c;\n-            this.path = prefix;\n-        }\n-\n-        @Override\n-        public IndexRow next() {\n-            final IndexRow r = c.next();\n-            return new IndexRow() {\n-\n-                @Override\n-                public String getPath() {\n-                    String sub = r.getPath();\n-                    if (PathUtils.isAbsolute(sub)) {\n-                        return path + sub;\n-                    } else {\n-                        return PathUtils.concat(path, r.getPath());\n-                    }\n-                }\n-\n-                @Override\n-                public PropertyValue getValue(String columnName) {\n-                    return r.getValue(columnName);\n-                }\n-            };\n-        }\n-\n-        @Override\n-        public boolean hasNext() {\n-            return c.hasNext();\n-        }\n-    }\n-\n     /**\n      * A cursor that reads all nodes in a given subtree.\n      */\n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 118, 
  "jira_id": "1977", 
  "nb_skipped": 9, 
  "commit": "4bfbfcdd", 
  "nb_failure": 2, 
  "linesRem": 86
}