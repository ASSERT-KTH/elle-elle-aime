{
  "files": 5, 
  "nb_test": 195, 
  "nb_error": 0, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.jackrabbit.mongomk.ConflictTest"
  ], 
  "patch": "diff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java\nindex 61652953e5..f9c1466f95 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Collision.java\n@@ -20,6 +20,8 @@\n \n import javax.annotation.Nonnull;\n \n+import org.apache.jackrabbit.mk.api.MicroKernelException;\n+import org.apache.jackrabbit.mongomk.DocumentStore.Collection;\n import org.apache.jackrabbit.mongomk.util.Utils;\n import org.apache.jackrabbit.oak.commons.PathUtils;\n import org.slf4j.Logger;\n@@ -29,7 +31,16 @@\n \n /**\n  * A <code>Collision</code> happens when a commit modifies a node, which was\n- * also modified in a branch commit, but the branch commit is not yet merged.\n+ * also modified in another branch not visible to the current session. This\n+ * includes the following situations:\n+ * <ul>\n+ * <li>Our commit goes to trunk and another session committed to a branch\n+ * not yet merged back.</li>\n+ * <li>Our commit goes to a branch and another session committed to trunk\n+ * or some other branch.</li>\n+ * </ul>\n+ * Other collisions like concurrent commits to trunk are handled earlier and\n+ * do not require collision marking. See {@link Commit#createOrUpdateNode()}.\n  */\n class Collision {\n \n@@ -50,47 +61,115 @@\n         this.ourRev = checkNotNull(ourRev).toString();\n     }\n \n-    boolean mark(DocumentStore store) {\n+    /**\n+     * Marks the collision in the document store. Either our or their\n+     * revision is annotated with a collision marker. Their revision is\n+     * marked if it is not yet committed, otherwise our revision is marked.\n+     * \n+     * @param store the document store.\n+     * @throws MicroKernelException if the mark operation fails.\n+     */\n+    void mark(DocumentStore store) throws MicroKernelException {\n+        // first try to mark their revision\n         if (markCommitRoot(document, theirRev, store)) {\n-            return true;\n+            return;\n         }\n-        @SuppressWarnings(\"unchecked\")\n-        Map<String, String> revisions = (Map<String, String>) document.get(UpdateOp.REVISIONS);\n-        if (revisions.containsKey(theirRev)) {\n-            String value = revisions.get(theirRev);\n-            if (\"true\".equals(value)) {\n         // their commit wins, we have to mark ourRev\n         Map<String, Object> newDoc = Utils.newMap();\n         Utils.deepCopyMap(document, newDoc);\n         MemoryDocumentStore.applyChanges(newDoc, ourOp);\n-                if (markCommitRoot(newDoc, ourRev, store)) {\n-                    return true;\n-                }\n+        if (!markCommitRoot(newDoc, ourRev, store)) {\n+            throw new MicroKernelException(\"Unable to annotate our revision \"\n+                    + \"with collision marker. Our revision: \" + ourRev\n+                    + \", document:\\n\" + Utils.formatDocument(newDoc));\n         }\n     }\n-        return true;\n-    }\n \n+    /**\n+     * Marks the commit root of the change to the given <code>document</code> in\n+     * <code>revision</code>.\n+     * \n+     * @param document the MongoDB document.\n+     * @param revision the revision of the commit to annotated with a collision\n+     *            marker.\n+     * @param store the document store.\n+     * @return <code>true</code> if the commit for the given revision was marked\n+     *         successfully; <code>false</code> otherwise.\n+     */\n     private static boolean markCommitRoot(@Nonnull Map<String, Object> document,\n                                           @Nonnull String revision,\n                                           @Nonnull DocumentStore store) {\n+        String p = Utils.getPathFromId((String) document.get(UpdateOp.ID));\n+        String commitRootPath = null;\n+        // first check if we can mark the commit with the given revision\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, String> revisions = (Map<String, String>) document.get(UpdateOp.REVISIONS);\n+        if (revisions != null && revisions.containsKey(revision)) {\n+            String value = revisions.get(revision);\n+            if (\"true\".equals(value)) {\n+                // already committed\n+                return false;\n+            } else {\n+                // node is also commit root, but not yet committed\n+                // i.e. a branch commit, which is not yet merged\n+                commitRootPath = p;\n+            }\n+        } else {\n+            // next look at commit root\n             @SuppressWarnings(\"unchecked\")\n             Map<String, Integer> commitRoots = (Map<String, Integer>) document.get(UpdateOp.COMMIT_ROOT);\n             if (commitRoots != null) {\n                 Integer depth = commitRoots.get(revision);\n                 if (depth != null) {\n-                String p = Utils.getPathFromId((String) document.get(UpdateOp.ID));\n-                String commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);\n+                    commitRootPath = PathUtils.getAncestorPath(p, PathUtils.getDepth(p) - depth);\n+                } else {\n+                    throwNoCommitRootException(revision, document);\n+                }\n+            } else {\n+                throwNoCommitRootException(revision, document);\n+            }\n+        }\n+        // at this point we have a commitRootPath\n         UpdateOp op = new UpdateOp(commitRootPath,\n                 Utils.getIdFromPath(commitRootPath), false);\n+        document = store.find(Collection.NODES, op.getKey());\n+        // check commit status of revision\n+        if (isCommitted(revision, document)) {\n+            return false;\n+        }\n         op.setMapEntry(UpdateOp.COLLISIONS, revision, true);\n-                // TODO: detect concurrent commit of previously un-merged changes\n-                // TODO: check _commitRoot for revision is not 'true'\n-                store.createOrUpdate(DocumentStore.Collection.NODES, op);\n+        document = store.createOrUpdate(DocumentStore.Collection.NODES, op);\n+        // check again on old document right before our update was applied\n+        if (isCommitted(revision, document)) {\n+            return false;\n+        }\n+        // otherwise collision marker was set successfully\n         LOG.debug(\"Marked collision on: {} for {} ({})\",\n                 new Object[]{commitRootPath, p, revision});\n         return true;\n     }\n+    \n+    private static void throwNoCommitRootException(@Nonnull String revision,\n+                                                   @Nonnull Map<String, Object> document)\n+                                                           throws MicroKernelException {\n+        throw new MicroKernelException(\"No commit root for revision: \"\n+                + revision + \", document: \" + Utils.formatDocument(document));\n+    }\n+    \n+    /**\n+     * Returns <code>true</code> if the given <code>revision</code> is marked\n+     * committed on the given <code>document</code>.\n+     * \n+     * @param revision the revision.\n+     * @param document a MongoDB document.\n+     * @return <code>true</code> if committed; <code>false</code> otherwise.\n+     */\n+    private static boolean isCommitted(String revision, Map<String, Object> document) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, String> revisions = (Map<String, String>) document.get(UpdateOp.REVISIONS);\n+        if (revisions != null && revisions.containsKey(revision)) {\n+            String value = revisions.get(revision);\n+            return \"true\".equals(value);\n         }\n         return false;\n     }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java\nindex 869512602c..b311ec9edc 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/CollisionHandler.java\n@@ -23,16 +23,16 @@\n \n     static final CollisionHandler DEFAULT = new CollisionHandler() {\n         @Override\n-        void uncommittedModification(Revision uncommitted) {\n+        void concurrentModification(Revision other) {\n             // do nothing\n         }\n     };\n \n     /**\n-     * Callback for an uncommitted modification in {@link Revision}\n-     * <code>uncommitted</code>.\n+     * Callback for an concurrent modification in {@link Revision}\n+     * <code>other</code>.\n      *\n-     * @param uncommitted the uncommitted revision of the change.\n+     * @param other the revision of the concurrent change.\n      */\n-    abstract void uncommittedModification(Revision uncommitted);\n+    abstract void concurrentModification(Revision other);\n }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java\nindex 5922f7eaf9..b565658e56 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/Commit.java\n@@ -268,11 +268,11 @@ private void createOrUpdateNode(DocumentStore store, UpdateOp op) {\n             Revision newestRev = mk.getNewestRevision(map, revision,\n                     new CollisionHandler() {\n                 @Override\n-                void uncommittedModification(Revision uncommitted) {\n+                void concurrentModification(Revision other) {\n                     if (collisions.get() == null) {\n                         collisions.set(new ArrayList<Revision>());\n                     }\n-                    collisions.get().add(uncommitted);\n+                    collisions.get().add(other);\n                 }\n             });\n             String conflictMessage = null;\n@@ -296,7 +296,7 @@ void uncommittedModification(Revision uncommitted) {\n             }\n             if (conflictMessage != null) {\n                 conflictMessage += \", before\\n\" + revision + \n-                        \"; document:\\n\" + map.toString().replaceAll(\", _\", \",\\n_\").replaceAll(\"}, \", \"},\\n\") + \n+                        \"; document:\\n\" + Utils.formatDocument(map) + \n                         \",\\nrevision order:\\n\" + mk.getRevisionComparator();\n                 throw new MicroKernelException(conflictMessage);\n             }\n@@ -306,11 +306,7 @@ void uncommittedModification(Revision uncommitted) {\n             if (collisions.get() != null && isConflicting(map, op)) {\n                 for (Revision r : collisions.get()) {\n                     // mark collisions on commit root\n-                    Collision c = new Collision(map, r, op, revision);\n-                    boolean success = c.mark(store);\n-                    if (!success) {\n-                        // TODO: fail this commit\n-                    }\n+                    new Collision(map, r, op, revision).mark(store);\n                 }\n             }\n         }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java\nindex a77ac51736..57f1fcc919 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/MongoMK.java\n@@ -1117,7 +1117,7 @@ private Revision getLiveRevision(Map<String, Object> nodeMap,\n      * \n      * @param nodeMap the document\n      * @param changeRev the revision of the current change\n-     * @param handler the conflict handler, which is called for un-committed revisions\n+     * @param handler the conflict handler, which is called for concurrent changes\n      *                preceding <code>before</code>.\n      * @return the revision, or null if deleted\n      */\n@@ -1152,7 +1152,7 @@ private Revision getLiveRevision(Map<String, Object> nodeMap,\n                 if (!propRev.equals(changeRev)) {\n                     if (!isValidRevision(\n                             propRev, changeRev, nodeMap, new HashSet<Revision>())) {\n-                        handler.uncommittedModification(propRev);\n+                        handler.concurrentModification(propRev);\n                     } else {\n                         newestRev = propRev;\n                     }\ndiff --git a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java\nindex 79eb21dab9..3fe75f34ce 100644\n--- a/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java\n+++ b/oak-mongomk/src/main/java/org/apache/jackrabbit/mongomk/util/Utils.java\n@@ -182,4 +182,14 @@ public static String getPathFromId(String id) {\n         }\n     }\n     \n+    /**\n+     * Formats a MongoDB document for use in a log message.\n+     * \n+     * @param document the MongoDB document.\n+     * @return\n+     */\n+    public static String formatDocument(Map<String, Object> document) {\n+    \treturn document.toString().replaceAll(\", _\", \",\\n_\").replaceAll(\"}, \", \"},\\n\");\n+    }\n+\n }\n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 118, 
  "jira_id": "846", 
  "nb_skipped": 4, 
  "commit": "7acb091a", 
  "nb_failure": 1, 
  "linesRem": 33
}