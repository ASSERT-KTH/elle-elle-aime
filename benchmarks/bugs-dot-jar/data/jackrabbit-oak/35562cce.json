{
  "files": 1, 
  "nb_test": 1809, 
  "nb_error": 1, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.jackrabbit.oak.plugins.index.property.PropertyIndexQueryTest"
  ], 
  "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\nindex 914881cac5..443f0cb26b 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/index/property/PropertyIndex.java\n@@ -30,6 +30,8 @@\n import org.apache.jackrabbit.oak.spi.query.Filter.PropertyRestriction;\n import org.apache.jackrabbit.oak.spi.query.QueryIndex;\n import org.apache.jackrabbit.oak.spi.state.NodeState;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.google.common.base.Charsets;\n import com.google.common.collect.Iterables;\n@@ -90,6 +92,8 @@\n      */\n     private static final String EMPTY_TOKEN = \":\";\n \n+    private static final Logger LOG = LoggerFactory.getLogger(PropertyIndex.class);\n+\n     static Set<String> encode(PropertyValue value) {\n         if (value == null) {\n             return null;\n@@ -113,6 +117,37 @@\n         return values;\n     }\n \n+    private Cheapest findCheapestProperty(Filter filter, PropertyIndexLookup lookup) {\n+        Cheapest cost = new Cheapest();\n+        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n+            String propertyName = PathUtils.getName(pr.propertyName);\n+            double propertyCost = Double.POSITIVE_INFINITY;\n+            // TODO support indexes on a path\n+            // currently, only indexes on the root node are supported\n+            if (lookup.isIndexed(propertyName, \"/\", filter)) {\n+                if (pr.firstIncluding && pr.lastIncluding\n+                    && pr.first != null && pr.first.equals(pr.last)) {\n+                    // \"[property] = $value\"\n+                    propertyCost = lookup.getCost(filter, propertyName, pr.first);\n+                } else if (pr.list != null) {\n+                    propertyCost = 0;\n+                    for (PropertyValue p : pr.list) {\n+                        propertyCost += lookup.getCost(filter, propertyName, p);\n+                    }\n+                } else {\n+                    // processed as \"[property] is not null\"\n+                    propertyCost = lookup.getCost(filter, propertyName, null);\n+                }\n+            }\n+            LOG.debug(\"property cost for {} is {}\", propertyName, propertyCost);\n+            if (propertyCost < cost.cost) {\n+                cost.cost = propertyCost;\n+                cost.propertyRestriction = pr;\n+            }\n+        }\n+        return cost;\n+    }\n+\n     //--------------------------------------------------------< QueryIndex >--\n \n     @Override\n@@ -142,29 +177,9 @@ public double getCost(Filter filter, NodeState root) {\n         }\n \n         PropertyIndexLookup lookup = getLookup(root);\n-        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n-            String propertyName = PathUtils.getName(pr.propertyName);\n-            // TODO support indexes on a path\n-            // currently, only indexes on the root node are supported\n-            if (lookup.isIndexed(propertyName, \"/\", filter)) {\n-                if (pr.firstIncluding && pr.lastIncluding\n-                    && pr.first != null && pr.first.equals(pr.last)) {\n-                    // \"[property] = $value\"\n-                    return lookup.getCost(filter, propertyName, pr.first);\n-                } else if (pr.list != null) {\n-                    double cost = 0;\n-                    for (PropertyValue p : pr.list) {\n-                        cost += lookup.getCost(filter, propertyName, p);\n-                    }\n-                    return cost;\n-                } else {\n-                    // processed as \"[property] is not null\"\n-                    return lookup.getCost(filter, propertyName, null);\n-                }\n-            }\n-        }\n-        // not an appropriate index\n-        return Double.POSITIVE_INFINITY;\n+        Cheapest cheapest = findCheapestProperty(filter, lookup);\n+        LOG.debug(\"Cheapest property cost is {} for property {}\", cheapest.cost, cheapest.propertyRestriction != null ? cheapest.propertyRestriction.propertyName : null);\n+        return cheapest.cost;\n     }\n \n     @Override\n@@ -173,7 +188,11 @@ public Cursor query(Filter filter, NodeState root) {\n \n         PropertyIndexLookup lookup = getLookup(root);\n         int depth = 1;\n-        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n+\n+        Cheapest cheapest = findCheapestProperty(filter, lookup);\n+        PropertyRestriction pr = cheapest.propertyRestriction;\n+\n+        if (pr != null) {\n             String propertyName = PathUtils.getName(pr.propertyName);\n             depth = PathUtils.getDepth(pr.propertyName);\n             // TODO support indexes on a path\n@@ -184,7 +203,6 @@ public Cursor query(Filter filter, NodeState root) {\n                     && pr.first != null && pr.first.equals(pr.last)) {\n                     // \"[property] = $value\"\n                     paths = lookup.query(filter, propertyName, pr.first);\n-                    break;\n                 } else if (pr.list != null) {\n                     for (PropertyValue pv : pr.list) {\n                         Iterable<String> p = lookup.query(filter, propertyName, pv);\n@@ -194,11 +212,9 @@ public Cursor query(Filter filter, NodeState root) {\n                             paths = Iterables.concat(paths, p);\n                         }\n                     }\n-                    break;\n                 } else {\n                     // processed as \"[property] is not null\"\n                     paths = lookup.query(filter, propertyName, null);\n-                    break;\n                 }\n             }\n         }\n@@ -217,7 +233,10 @@ public String getPlan(Filter filter, NodeState root) {\n         StringBuilder buff = new StringBuilder(\"property\");\n         StringBuilder notIndexed = new StringBuilder();\n         PropertyIndexLookup lookup = getLookup(root);\n-        for (PropertyRestriction pr : filter.getPropertyRestrictions()) {\n+        Cheapest cheapest = findCheapestProperty(filter, lookup);\n+        PropertyRestriction pr = cheapest.propertyRestriction;\n+\n+        if (pr != null) {\n             String propertyName = PathUtils.getName(pr.propertyName);\n             // TODO support indexes on a path\n             // currently, only indexes on the root node are supported\n@@ -251,4 +270,9 @@ public String getPlan(Filter filter, NodeState root) {\n         return buff.toString();\n     }\n \n+    private static class Cheapest {\n+        private double cost = Double.POSITIVE_INFINITY;\n+        private PropertyRestriction propertyRestriction;\n+    }\n+\n }\n\\ No newline at end of file\n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 52, 
  "jira_id": "1894", 
  "nb_skipped": 9, 
  "commit": "35562cce", 
  "nb_failure": 0, 
  "linesRem": 28
}