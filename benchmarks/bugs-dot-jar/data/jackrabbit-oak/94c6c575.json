{
  "files": 4, 
  "nb_test": 3065, 
  "nb_error": 2, 
  "classification": {
    "singleLine": false
  }, 
  "failing_tests": [
    "org.apache.jackrabbit.oak.plugins.document.DocumentMKResetTest"
  ], 
  "patch": "diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\nindex 8643bf7ed7..7fb76bba88 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentMK.java\n@@ -335,7 +335,7 @@ public String reset(@Nonnull String branchRevisionId,\n             throw new DocumentStoreException(\"Not a branch revision: \" + ancestorRevisionId);\n         }\n         try {\n-            return nodeStore.reset(branch, ancestor, null).toString();\n+            return nodeStore.reset(branch, ancestor).toString();\n         } catch (DocumentStoreException e) {\n             throw new DocumentStoreException(e);\n         }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\nindex fcc6bf9549..14e608ffc4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java\n@@ -22,6 +22,8 @@\n import static com.google.common.collect.Iterables.filter;\n import static com.google.common.collect.Iterables.toArray;\n import static com.google.common.collect.Iterables.transform;\n+import static com.google.common.collect.Lists.newArrayList;\n+import static com.google.common.collect.Lists.reverse;\n import static java.util.Collections.singletonList;\n import static org.apache.jackrabbit.oak.commons.PathUtils.concat;\n import static org.apache.jackrabbit.oak.plugins.document.Collection.JOURNAL;\n@@ -81,6 +83,7 @@\n import org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob;\n import org.apache.jackrabbit.oak.plugins.blob.MarkSweepGarbageCollector;\n import org.apache.jackrabbit.oak.plugins.blob.ReferencedBlob;\n+import org.apache.jackrabbit.oak.plugins.document.Branch.BranchCommit;\n import org.apache.jackrabbit.oak.plugins.document.cache.CacheInvalidationStats;\n import org.apache.jackrabbit.oak.plugins.document.persistentCache.PersistentCache;\n import org.apache.jackrabbit.oak.plugins.document.persistentCache.broadcast.DynamicBroadcastConfig;\n@@ -1249,8 +1252,7 @@ RevisionVector rebase(@Nonnull RevisionVector branchHead,\n \n     @Nonnull\n     RevisionVector reset(@Nonnull RevisionVector branchHead,\n-                         @Nonnull RevisionVector ancestor,\n-                         @Nullable DocumentNodeStoreBranch branch) {\n+                         @Nonnull RevisionVector ancestor) {\n         checkNotNull(branchHead);\n         checkNotNull(ancestor);\n         Branch b = getBranches().getBranch(branchHead);\n@@ -1261,61 +1263,44 @@ RevisionVector reset(@Nonnull RevisionVector branchHead,\n             throw new DocumentStoreException(branchHead + \" is not the head \" +\n                     \"of a branch\");\n         }\n-        if (!b.containsCommit(ancestor.getBranchRevision())) {\n+        if (!b.containsCommit(ancestor.getBranchRevision())\n+                && !b.getBase().asBranchRevision(getClusterId()).equals(ancestor)) {\n             throw new DocumentStoreException(ancestor + \" is not \" +\n                     \"an ancestor revision of \" + branchHead);\n         }\n-        if (branchHead.equals(ancestor)) {\n+        // tailSet is inclusive -> use an ancestorRev with a\n+        // counter incremented by one to make the call exclusive\n+        Revision ancestorRev = ancestor.getBranchRevision();\n+        ancestorRev = new Revision(ancestorRev.getTimestamp(),\n+                ancestorRev.getCounter() + 1, ancestorRev.getClusterId(), true);\n+        List<Revision> revs = newArrayList(b.getCommits().tailSet(ancestorRev));\n+        if (revs.isEmpty()) {\n             // trivial\n             return branchHead;\n         }\n-        boolean success = false;\n-        Commit commit = newCommit(branchHead, branch);\n-        try {\n-            Iterator<Revision> it = b.getCommits().tailSet(ancestor.getBranchRevision()).iterator();\n-            // first revision is the ancestor (tailSet is inclusive)\n-            // do not undo changes for this revision\n-            it.next();\n+        UpdateOp rootOp = new UpdateOp(Utils.getIdFromPath(\"/\"), false);\n+        // reset each branch commit in reverse order\n         Map<String, UpdateOp> operations = Maps.newHashMap();\n-            if (it.hasNext()) {\n-                Revision reset = it.next();\n-                // TODO: correct?\n-                getRoot(b.getCommit(reset).getBase().update(reset))\n-                        .compareAgainstBaseState(getRoot(ancestor),\n-                                new ResetDiff(reset.asTrunkRevision(), operations));\n-                UpdateOp rootOp = operations.get(\"/\");\n-                if (rootOp == null) {\n-                    rootOp = new UpdateOp(Utils.getIdFromPath(\"/\"), false);\n-                    NodeDocument.setModified(rootOp, commit.getRevision());\n-                    operations.put(\"/\", rootOp);\n-                }\n-                NodeDocument.removeCollision(rootOp, reset.asTrunkRevision());\n-                NodeDocument.removeRevision(rootOp, reset.asTrunkRevision());\n-            }\n-            // update root document first\n-            if (store.findAndUpdate(Collection.NODES, operations.get(\"/\")) != null) {\n-                // clean up in-memory branch data\n-                // first revision is the ancestor (tailSet is inclusive)\n-                List<Revision> revs = Lists.newArrayList(b.getCommits().tailSet(ancestor.getBranchRevision()));\n-                for (Revision r : revs.subList(1, revs.size())) {\n-                    b.removeCommit(r);\n-                }\n-                // successfully updating the root document can be considered\n-                // as success because the changes are not marked as committed\n-                // anymore\n-                success = true;\n+        for (Revision r : reverse(revs)) {\n+            NodeDocument.removeCollision(rootOp, r.asTrunkRevision());\n+            NodeDocument.removeRevision(rootOp, r.asTrunkRevision());\n+            operations.clear();\n+            BranchCommit bc = b.getCommit(r);\n+            if (bc.isRebase()) {\n+                continue;\n             }\n-            operations.remove(\"/\");\n-            // update remaining documents\n+            getRoot(bc.getBase().update(r))\n+                    .compareAgainstBaseState(getRoot(bc.getBase()),\n+                            new ResetDiff(r.asTrunkRevision(), operations));\n+            // apply reset operations\n             for (UpdateOp op : operations.values()) {\n                 store.findAndUpdate(Collection.NODES, op);\n             }\n-        } finally {\n-            if (!success) {\n-                canceled(commit);\n-            } else {\n-                done(commit, true, null);\n         }\n+        store.findAndUpdate(Collection.NODES, rootOp);\n+        // clean up in-memory branch data\n+        for (Revision r : revs) {\n+            b.removeCommit(r);\n         }\n         return ancestor;\n     }\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java\nindex 4a022136fc..6e994221aa 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStoreBranch.java\n@@ -620,8 +620,7 @@ private void resetBranch(DocumentNodeState branchHead, DocumentNodeState ancesto\n             try {\n                 head = store.getRoot(\n                         store.reset(branchHead.getRevision(), \n-                                ancestor.getRevision(), \n-                                DocumentNodeStoreBranch.this));\n+                                ancestor.getRevision()));\n             } catch (Exception e) {\n                 CommitFailedException ex = new CommitFailedException(\n                         OAK, 100, \"Branch reset failed\", e);\ndiff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java\nindex 239928fdd3..cc086354c4 100644\n--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java\n+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/ResetDiff.java\n@@ -74,6 +74,7 @@ public boolean propertyDeleted(PropertyState before) {\n \n     @Override\n     public boolean childNodeAdded(String name, NodeState after) {\n+        NodeDocument.removeCommitRoot(getUpdateOp(), revision);\n         String p = PathUtils.concat(path, name);\n         ResetDiff diff = new ResetDiff(revision, p, operations);\n         UpdateOp op = diff.getUpdateOp();\n", 
  "project": "jackrabbit-oak", 
  "linesAdd": 33, 
  "jira_id": "3897", 
  "nb_skipped": 1, 
  "commit": "94c6c575", 
  "nb_failure": 1, 
  "linesRem": 48
}